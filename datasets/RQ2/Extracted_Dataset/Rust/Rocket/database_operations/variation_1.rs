/*
 * VARIATION 1: The "Classic" Service/Repository Pattern
 *
 * This implementation follows a traditional layered architecture.
 * - `handlers`: Contains Rocket route handlers. Responsible for HTTP concerns.
 * - `services`: Business logic layer (omitted for brevity, handlers call repositories directly).
 * - `repositories`: Data access layer. All Diesel/SQL logic is encapsulated here.
 * - `models`: Plain data structures (entities) with no database logic.
 * - `schema`: Auto-generated by Diesel.
 *
 * PROS: Excellent separation of concerns, highly testable, scalable for large teams.
 * CONS: Can be verbose with more boilerplate for simple operations.
 */

// To compile and run this example:
// 1. Create a new Rust project: `cargo new rocket_db_demo`
// 2. Add the following to `Cargo.toml`:
/*
[dependencies]
rocket = { version = "0.5.0", features = ["json"] }
rocket_db_pools = { version = "0.1.0", features = ["diesel_postgres"] }
diesel = { version = "2.1.4", features = ["postgres", "uuid", "chrono", "r2d2"] }
diesel_migrations = { version = "2.1.0", features = ["postgres"] }
serde = { version = "1.0", features = ["derive"] }
uuid = { version = "1.6", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
bcrypt = "0.15"
validator = { version = "0.16", features = ["derive"] }
thiserror = "1.0"
dotenvy = "0.15"

[dependencies.rocket::dependencies]
serde_json = "1.0"
*/
// 3. Setup Diesel CLI: `cargo install diesel_cli --no-default-features --features postgres`
// 4. Create a `.env` file with `DATABASE_URL=postgres://user:password@localhost/dbname`
// 5. Run `diesel setup`
// 6. Create migrations:
//    - `diesel migration generate create_initial_schema`
//    - Edit the `up.sql` and `down.sql` files with the SQL provided in the `run_migrations` function comments.
// 7. Create `Rocket.toml` in the project root:
/*
[default.databases.postgres_db]
url = { env = "DATABASE_URL" }
*/
// 8. Replace `src/main.rs` with this code and run `cargo run`.

#[macro_use]
extern crate rocket;
#[macro_use]
extern crate diesel;
#[macro_use]
extern crate diesel_migrations;

use rocket::fairing::{self, AdHoc};
use rocket::http::Status;
use rocket::response::status;
use rocket::serde::json::Json;
use rocket::{Build, Rocket};
use rocket_db_pools::{diesel::PgConnection, Connection, Database};

// Main entry point
#[launch]
fn rocket() -> _ {
    dotenvy::dotenv().ok();
    rocket::build()
        .attach(DbConn::init())
        .attach(AdHoc::try_on_ignite("Diesel Migrations", run_migrations))
        .mount(
            "/",
            routes![
                handlers::user_handler::create_user,
                handlers::user_handler::get_user_with_posts,
                handlers::user_handler::assign_role_to_user,
                handlers::user_handler::create_user_and_first_post,
                handlers::post_handler::get_posts_filtered,
            ],
        )
}

// Rocket's database pool fairing
#[derive(Database)]
#[database("postgres_db")]
pub struct DbConn(PgConnection);

// Diesel migrations runner
embed_migrations!("./migrations");
async fn run_migrations(rocket: Rocket<Build>) -> fairing::Result {
    // SQL for migrations/2023-11-20-120000_create_initial_schema/up.sql
    /*
    -- Create custom enum types
    CREATE TYPE post_status AS ENUM ('DRAFT', 'PUBLISHED');

    -- Create Users Table
    CREATE TABLE users (
        id UUID PRIMARY KEY,
        email VARCHAR(255) NOT NULL UNIQUE,
        password_hash VARCHAR(255) NOT NULL,
        is_active BOOLEAN NOT NULL DEFAULT true,
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    -- Create Posts Table
    CREATE TABLE posts (
        id UUID PRIMARY KEY,
        user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        title VARCHAR(255) NOT NULL,
        content TEXT NOT NULL,
        status post_status NOT NULL DEFAULT 'DRAFT'
    );

    -- Create Roles Table
    CREATE TABLE roles (
        id UUID PRIMARY KEY,
        name VARCHAR(50) NOT NULL UNIQUE
    );

    -- Create UserRoles Join Table
    CREATE TABLE user_roles (
        user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        role_id UUID NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
        PRIMARY KEY (user_id, role_id)
    );

    -- Seed initial roles
    INSERT INTO roles (id, name) VALUES
        (gen_random_uuid(), 'ADMIN'),
        (gen_random_uuid(), 'USER');
    */
    match DbConn::get_one(&rocket).await {
        Ok(conn) => {
            conn.run(|c| match embedded_migrations::run(c) {
                Ok(_) => Ok(rocket),
                Err(e) => {
                    error!("Failed to run Diesel migrations: {:?}", e);
                    Err(rocket)
                }
            })
            .await
        }
        Err(e) => {
            error!("Failed to get DB connection for migrations: {:?}", e);
            Err(rocket)
        }
    }
}

// ============== SCHEMA ==============
mod schema {
    diesel::table! {
        use diesel::sql_types::*;
        use super::models::PostStatusMapping;

        posts (id) {
            id -> Uuid,
            user_id -> Uuid,
            title -> Varchar,
            content -> Text,
            status -> PostStatusMapping,
        }
    }

    diesel::table! {
        roles (id) {
            id -> Uuid,
            name -> Varchar,
        }
    }

    diesel::table! {
        user_roles (user_id, role_id) {
            user_id -> Uuid,
            role_id -> Uuid,
        }
    }

    diesel::table! {
        users (id) {
            id -> Uuid,
            email -> Varchar,
            password_hash -> Varchar,
            is_active -> Bool,
            created_at -> Timestamptz,
        }
    }

    diesel::joinable!(posts -> users (user_id));
    diesel::joinable!(user_roles -> roles (role_id));
    diesel::joinable!(user_roles -> users (user_id));

    diesel::allow_tables_to_appear_in_same_query!(
        posts,
        roles,
        user_roles,
        users,
    );
}

// ============== MODELS ==============
mod models {
    use super::schema::{posts, roles, user_roles, users};
    use chrono::{DateTime, Utc};
    use diesel::prelude::*;
    use serde::{Deserialize, Serialize};
    use uuid::Uuid;
    use validator::Validate;

    // --- Enums and their Diesel mappings ---
    #[derive(Debug, Clone, Copy, PartialEq, Eq, diesel_derive_enum::DbEnum, Serialize, Deserialize)]
    #[ExistingTypePath = "crate::schema::sql_types::PostStatusMapping"]
    pub enum PostStatus {
        DRAFT,
        PUBLISHED,
    }

    // --- Database Entities ---
    #[derive(Queryable, Selectable, Identifiable, Serialize, Debug)]
    #[diesel(table_name = users)]
    pub struct User {
        pub id: Uuid,
        pub email: String,
        #[serde(skip)]
        pub password_hash: String,
        pub is_active: bool,
        pub created_at: DateTime<Utc>,
    }

    #[derive(Queryable, Selectable, Identifiable, Associations, Serialize, Debug)]
    #[diesel(belongs_to(User))]
    #[diesel(table_name = posts)]
    pub struct Post {
        pub id: Uuid,
        pub user_id: Uuid,
        pub title: String,
        pub content: String,
        pub status: PostStatus,
    }

    #[derive(Queryable, Selectable, Identifiable, Serialize, Debug)]
    #[diesel(table_name = roles)]
    pub struct Role {
        pub id: Uuid,
        pub name: String,
    }

    #[derive(Queryable, Selectable, Identifiable, Associations, Debug)]
    #[diesel(belongs_to(User))]
    #[diesel(belongs_to(Role))]
    #[diesel(table_name = user_roles)]
    #[diesel(primary_key(user_id, role_id))]
    pub struct UserRole {
        pub user_id: Uuid,
        pub role_id: Uuid,
    }

    // --- Structs for Insertions ---
    #[derive(Insertable)]
    #[diesel(table_name = users)]
    pub struct NewUser<'a> {
        pub id: Uuid,
        pub email: &'a str,
        pub password_hash: &'a str,
    }

    #[derive(Insertable)]
    #[diesel(table_name = posts)]
    pub struct NewPost<'a> {
        pub id: Uuid,
        pub user_id: Uuid,
        pub title: &'a str,
        pub content: &'a str,
    }

    #[derive(Insertable)]
    #[diesel(table_name = user_roles)]
    pub struct NewUserRole {
        pub user_id: Uuid,
        pub role_id: Uuid,
    }

    // --- DTOs for API Payloads ---
    #[derive(Deserialize, Validate)]
    pub struct CreateUserDto {
        #[validate(email)]
        pub email: String,
        #[validate(length(min = 8))]
        pub password: String,
    }

    #[derive(Deserialize)]
    pub struct AssignRoleDto {
        pub user_id: Uuid,
        pub role_name: String,
    }
    
    #[derive(Deserialize)]
    pub struct CreatePostDto {
        pub title: String,
        pub content: String,
    }

    // --- Composite Structs for API Responses ---
    #[derive(Serialize)]
    pub struct UserWithPostsAndRoles {
        pub user: User,
        pub posts: Vec<Post>,
        pub roles: Vec<Role>,
    }
}

// ============== REPOSITORIES ==============
mod repositories {
    use super::models::*;
    use super::schema::{posts, roles, user_roles, users};
    use super::DbConn;
    use diesel::prelude::*;
    use rocket_db_pools::Connection;
    use thiserror::Error;
    use uuid::Uuid;

    #[derive(Error, Debug)]
    pub enum RepoError {
        #[error("Database query failed: {0}")]
        DieselError(#[from] diesel::result::Error),
        #[error("Entity not found")]
        NotFound,
        #[error("Database connection error")]
        ConnectionError,
    }

    type RepoResult<T> = Result<T, RepoError>;

    // --- User Repository ---
    pub struct UserRepository;
    impl UserRepository {
        pub async fn create(db: &mut Connection<DbConn>, new_user: NewUser<'_>) -> RepoResult<User> {
            db.run(move |conn| {
                diesel::insert_into(users::table)
                    .values(&new_user)
                    .get_result(conn)
            })
            .await
            .map_err(RepoError::from)
        }

        pub async fn find_by_id(db: &mut Connection<DbConn>, user_id: Uuid) -> RepoResult<User> {
            db.run(move |conn| users::table.find(user_id).first(conn))
                .await
                .map_err(|e| match e {
                    diesel::result::Error::NotFound => RepoError::NotFound,
                    _ => RepoError::from(e),
                })
        }
    }

    // --- Post Repository ---
    pub struct PostRepository;
    impl PostRepository {
        pub async fn create(db: &mut Connection<DbConn>, new_post: NewPost<'_>) -> RepoResult<Post> {
            db.run(move |conn| {
                diesel::insert_into(posts::table)
                    .values(&new_post)
                    .get_result(conn)
            })
            .await
            .map_err(RepoError::from)
        }

        pub async fn find_by_user(db: &mut Connection<DbConn>, user_id: Uuid) -> RepoResult<Vec<Post>> {
            db.run(move |conn| Post::belonging_to(&User { id: user_id, email: String::new(), password_hash: String::new(), is_active: true, created_at: chrono::Utc::now() }).load(conn))
                .await
                .map_err(RepoError::from)
        }

        pub async fn find_with_filters(db: &mut Connection<DbConn>, status: Option<PostStatus>) -> RepoResult<Vec<Post>> {
            db.run(move |conn| {
                let mut query = posts::table.into_boxed();
                if let Some(s) = status {
                    query = query.filter(posts::status.eq(s));
                }
                query.load(conn)
            })
            .await
            .map_err(RepoError::from)
        }
    }

    // --- Role Repository ---
    pub struct RoleRepository;
    impl RoleRepository {
        pub async fn find_by_name(db: &mut Connection<DbConn>, name: String) -> RepoResult<Role> {
            db.run(move |conn| roles::table.filter(roles::name.eq(name)).first(conn))
                .await
                .map_err(|e| match e {
                    diesel::result::Error::NotFound => RepoError::NotFound,
                    _ => RepoError::from(e),
                })
        }

        pub async fn find_by_user(db: &mut Connection<DbConn>, user_id: Uuid) -> RepoResult<Vec<Role>> {
            db.run(move |conn| {
                user_roles::table
                    .filter(user_roles::user_id.eq(user_id))
                    .inner_join(roles::table)
                    .select(Role::as_select())
                    .load(conn)
            })
            .await
            .map_err(RepoError::from)
        }

        pub async fn assign_to_user(db: &mut Connection<DbConn>, user_id: Uuid, role_id: Uuid) -> RepoResult<()> {
            let new_user_role = NewUserRole { user_id, role_id };
            db.run(move |conn| {
                diesel::insert_into(user_roles::table)
                    .values(&new_user_role)
                    .on_conflict_do_nothing()
                    .execute(conn)
            })
            .await?;
            Ok(())
        }
    }
    
    // --- Transactional Operations ---
    pub async fn create_user_with_post_tx(
        db: &mut Connection<DbConn>,
        new_user: NewUser<'_>,
        new_post: NewPost<'_>,
    ) -> RepoResult<(User, Post)> {
        db.run(|conn| {
            conn.transaction(|transaction_conn| {
                let user: User = diesel::insert_into(users::table)
                    .values(&new_user)
                    .get_result(transaction_conn)?;

                let post: Post = diesel::insert_into(posts::table)
                    .values(&new_post)
                    .get_result(transaction_conn)?;
                
                // Example of a rollback condition. If title is "FAIL", transaction will be rolled back.
                if new_post.title == "FAIL" {
                    return Err(diesel::result::Error::RollbackTransaction);
                }

                Ok((user, post))
            })
        })
        .await
        .map_err(RepoError::from)
    }
}

// ============== HANDLERS (Routes) ==============
mod handlers {
    use super::models::{CreateUserDto, UserWithPostsAndRoles, AssignRoleDto, CreatePostDto, PostStatus};
    use super::repositories::{PostRepository, RepoError, RoleRepository, UserRepository, create_user_with_post_tx};
    use super::{DbConn, models, schema};
    use rocket::http::Status;
    use rocket::response::status;
    use rocket::serde::json::Json;
    use rocket_db_pools::Connection;
    use uuid::Uuid;
    use validator::Validate;

    // Custom error response for API
    type ApiResult<T> = Result<T, status::Custom<String>>;

    fn repo_error_to_api_error(e: RepoError) -> status::Custom<String> {
        let status = match e {
            RepoError::NotFound => Status::NotFound,
            _ => Status::InternalServerError,
        };
        status::Custom(status, e.to_string())
    }

    pub mod user_handler {
        use super::*;

        #[post("/users", format = "json", data = "<user_dto>")]
        pub async fn create_user(
            mut db: Connection<DbConn>,
            user_dto: Json<CreateUserDto>,
        ) -> ApiResult<Json<models::User>> {
            user_dto.validate().map_err(|e| status::Custom(Status::BadRequest, e.to_string()))?;
            
            let hashed_password = bcrypt::hash(&user_dto.password, bcrypt::DEFAULT_COST)
                .map_err(|_| status::Custom(Status::InternalServerError, "Password hashing failed".into()))?;

            let new_user = models::NewUser {
                id: Uuid::new_v4(),
                email: &user_dto.email,
                password_hash: &hashed_password,
            };

            let user = UserRepository::create(&mut db, new_user)
                .await
                .map_err(repo_error_to_api_error)?;

            Ok(Json(user))
        }

        #[get("/users/<id>")]
        pub async fn get_user_with_posts(
            mut db: Connection<DbConn>,
            id: Uuid,
        ) -> ApiResult<Json<UserWithPostsAndRoles>> {
            let user = UserRepository::find_by_id(&mut db, id).await.map_err(repo_error_to_api_error)?;
            let posts = PostRepository::find_by_user(&mut db, id).await.map_err(repo_error_to_api_error)?;
            let roles = RoleRepository::find_by_user(&mut db, id).await.map_err(repo_error_to_api_error)?;

            Ok(Json(UserWithPostsAndRoles { user, posts, roles }))
        }

        #[post("/users/roles", format = "json", data = "<assign_dto>")]
        pub async fn assign_role_to_user(
            mut db: Connection<DbConn>,
            assign_dto: Json<AssignRoleDto>,
        ) -> ApiResult<status::NoContent> {
            let role = RoleRepository::find_by_name(&mut db, assign_dto.role_name.clone())
                .await
                .map_err(repo_error_to_api_error)?;
            
            RoleRepository::assign_to_user(&mut db, assign_dto.user_id, role.id)
                .await
                .map_err(repo_error_to_api_error)?;

            Ok(status::NoContent)
        }

        #[post("/users/transactional", format = "json", data = "<user_dto>")]
        pub async fn create_user_and_first_post(
            mut db: Connection<DbConn>,
            user_dto: Json<CreateUserDto>,
        ) -> ApiResult<status::Created<String>> {
            user_dto.validate().map_err(|e| status::Custom(Status::BadRequest, e.to_string()))?;

            let hashed_password = bcrypt::hash(&user_dto.password, bcrypt::DEFAULT_COST)
                .map_err(|_| status::Custom(Status::InternalServerError, "Password hashing failed".into()))?;
            
            let user_id = Uuid::new_v4();
            let new_user = models::NewUser {
                id: user_id,
                email: &user_dto.email,
                password_hash: &hashed_password,
            };
            let new_post = models::NewPost {
                id: Uuid::new_v4(),
                user_id,
                title: "My First Post",
                content: "Hello, world!",
            };

            create_user_with_post_tx(&mut db, new_user, new_post)
                .await
                .map_err(repo_error_to_api_error)?;

            Ok(status::Created::new(format!("/users/{}", user_id)))
        }
    }

    pub mod post_handler {
        use super::*;

        #[get("/posts?<status>")]
        pub async fn get_posts_filtered(
            mut db: Connection<DbConn>,
            status: Option<PostStatus>,
        ) -> ApiResult<Json<Vec<models::Post>>> {
            let posts = PostRepository::find_with_filters(&mut db, status)
                .await
                .map_err(repo_error_to_api_error)?;
            Ok(Json(posts))
        }
    }
}