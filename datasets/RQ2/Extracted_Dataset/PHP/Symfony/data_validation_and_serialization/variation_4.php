<?php

// This variation showcases a "modern and concise" developer style.
// It leverages PHP 8 features like constructor property promotion and enums extensively.
// The `Callback` constraint is used for a simple, inline custom validation rule.
// The controller is extremely lean, relying on Symfony's built-in features like `MapRequestPayload`
// and automatic exception handling to do the heavy lifting, resulting in minimal boilerplate.

// --- Mocks and Stubs for self-containment ---
namespace App\Domain\Enums {
    enum PostStatus: string {
        case DRAFT = 'draft';
        case PUBLISHED = 'published';
    }
}

namespace App\Http\DTO {
    use App\Domain\Enums\PostStatus;
    use Symfony\Component\Validator\Constraints as Assert;
    use Symfony\Component\Validator\Context\ExecutionContextInterface;

    // DTO using constructor property promotion for maximum conciseness.
    readonly class CreatePostDto
    {
        public function __construct(
            #[Assert\NotBlank]
            #[Assert\Length(min: 5, max: 100)]
            public string $title,

            #[Assert\NotBlank]
            #[Assert\Length(min: 20)]
            public string $content,

            // Type coercion: "draft" or "published" string from JSON will be cast to the enum.
            #[Assert\NotNull]
            public PostStatus $status = PostStatus::DRAFT,

            /** @var string[] */
            #[Assert\All([new Assert\NotBlank(), new Assert\Type('string')])]
            #[Assert\Count(min: 1, max: 5)]
            public array $tags = []
        ) {}

        // Custom validator using an inline callback.
        // Useful for simple rules that don't warrant a separate validator class.
        #[Assert\Callback]
        public function validate(ExecutionContextInterface $context, mixed $payload): void
        {
            if (stripos($this->content, $this->title) !== false) {
                $context->buildViolation('The post content cannot contain the title.')
                    ->atPath('content')
                    ->addViolation();
            }
        }
    }
}

namespace App\Domain\Entity {
    use App\Domain\Enums\PostStatus;
    use Symfony\Component\Uid\Uuid;
    class Post {
        public function __construct(
            public Uuid $id,
            public Uuid $user_id,
            public string $title,
            public string $content,
            public PostStatus $status
        ) {}
    }
}

namespace App\Controller\Api\V1 {
    use App\Domain\Entity\Post;
    use App\Http\DTO\CreatePostDto;
    use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
    use Symfony\Component\HttpFoundation\JsonResponse;
    use Symfony\Component\HttpFoundation\Response;
    use Symfony\Component\HttpKernel\Attribute\MapRequestPayload;
    use Symfony\Component\Routing\Annotation\Route;
    use Symfony\Component\Uid\Uuid;

    #[Route('/api/v1')]
    class PostController extends AbstractController
    {
        /**
         * The controller action is extremely lean.
         * Deserialization and validation are fully handled by #[MapRequestPayload].
         * If validation fails, a 422 response is automatically generated by Symfony's
         * default exception listener, so no explicit error handling is needed here for the common case.
         */
        #[Route('/posts', methods: ['POST'])]
        public function create(
            #[MapRequestPayload(
                acceptFormat: 'json',
                validationFailedStatusCode: Response::HTTP_UNPROCESSABLE_ENTITY
            )] CreatePostDto $postDto
        ): JsonResponse {
            // Business logic: create a Post entity from the validated DTO.
            $post = new Post(
                id: Uuid::v4(),
                user_id: Uuid::v4(), // In a real app, this would come from the authenticated user.
                title: $postDto->title,
                content: $postDto->content,
                status: $postDto->status
            );

            // Mock saving the post to the database.
            // $this->postRepository->save($post);

            return $this->json(
                ['id' => (string)$post->id, 'message' => 'Post created successfully.'],
                Response::HTTP_CREATED
            );
        }
    }
}