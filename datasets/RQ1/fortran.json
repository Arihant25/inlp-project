[
    {
        "id": 1,
        "code": "program read_file\n  implicit none\n  integer :: unit_num, iostat\n  character(len=100) :: line\n  open(newunit=unit_num, file='data.txt', status='old', action='read')\n  do\n    read(unit_num, '(A)', iostat=iostat) line\n    if (iostat /= 0) exit\n    print *, trim(line)\n  end do\n  close(unit_num)\nend program read_file",
        "summary": "Reads a file named 'data.txt' line by line and prints each line to the standard output until the end of the file is reached."
    },
    {
        "id": 2,
        "code": "subroutine count_lines(filename, count)\n  implicit none\n  character(len=*), intent(in) :: filename\n  integer, intent(out) :: count\n  integer :: unit, ios\n  count = 0\n  open(newunit=unit, file=filename, status='old', iostat=ios)\n  if (ios == 0) then\n    do\n      read(unit, *, iostat=ios)\n      if (ios /= 0) exit\n      count = count + 1\n    end do\n    close(unit)\n  end if\nend subroutine count_lines",
        "summary": "A subroutine that counts the total number of lines in a specified file and returns the count."
    },
    {
        "id": 3,
        "code": "program write_hello\n  implicit none\n  integer :: u\n  open(newunit=u, file='output.txt', status='replace', action='write')\n  write(u, '(A)') 'Hello, World!'\n  close(u)\nend program write_hello",
        "summary": "Creates or overwrites a file named 'output.txt' and writes the string 'Hello, World!' to it."
    },
    {
        "id": 4,
        "code": "function file_exists(filename) result(exists)\n  implicit none\n  character(len=*), intent(in) :: filename\n  logical :: exists\n  inquire(file=filename, exist=exists)\nend function file_exists",
        "summary": "Checks if a file exists at the specified path and returns a logical true or false."
    },
    {
        "id": 5,
        "code": "program append_text\n  implicit none\n  integer :: u\n  open(newunit=u, file='log.txt', status='old', position='append', action='write')\n  write(u, *) 'Log entry added.'\n  close(u)\nend program append_text",
        "summary": "Opens an existing file named 'log.txt' and appends a new log entry line to the end of it."
    },
    {
        "id": 6,
        "code": "subroutine read_first_line(fname, first_line)\n  implicit none\n  character(len=*), intent(in) :: fname\n  character(len=256), intent(out) :: first_line\n  integer :: u, io\n  open(newunit=u, file=fname, status='old', iostat=io)\n  if (io == 0) then\n    read(u, '(A)', iostat=io) first_line\n    close(u)\n  else\n    first_line = ''\n  end if\nend subroutine read_first_line",
        "summary": "Reads the first line of a specified file into a character variable."
    },
    {
        "id": 7,
        "code": "program copy_file\n  implicit none\n  integer :: src, dst, ios\n  character(len=1024) :: buffer\n  open(newunit=src, file='source.dat', status='old', access='stream')\n  open(newunit=dst, file='dest.dat', status='replace', access='stream')\n  do\n    read(src, iostat=ios) buffer\n    if (ios /= 0) exit\n    write(dst) trim(buffer)\n  end do\n  close(src)\n  close(dst)\nend program copy_file",
        "summary": "Copies the contents of 'source.dat' to 'dest.dat' using stream access."
    },
    {
        "id": 8,
        "code": "subroutine delete_file(filename)\n  implicit none\n  character(len=*), intent(in) :: filename\n  integer :: u\n  logical :: ex\n  inquire(file=filename, exist=ex)\n  if (ex) then\n    open(newunit=u, file=filename, status='old')\n    close(u, status='delete')\n  end if\nend subroutine delete_file",
        "summary": "Deletes a specified file from the filesystem if it exists."
    },
    {
        "id": 9,
        "code": "program count_chars\n  implicit none\n  integer :: u, count, ios\n  character :: c\n  count = 0\n  open(newunit=u, file='text.txt', status='old', access='stream')\n  do\n    read(u, iostat=ios) c\n    if (ios /= 0) exit\n    count = count + 1\n  end do\n  print *, 'Characters:', count\n  close(u)\nend program count_chars",
        "summary": "Counts the total number of characters in 'text.txt' by reading the file byte by byte."
    },
    {
        "id": 10,
        "code": "subroutine write_array_to_file(arr, n, fname)\n  implicit none\n  integer, intent(in) :: n\n  real, dimension(n), intent(in) :: arr\n  character(len=*), intent(in) :: fname\n  integer :: u, i\n  open(newunit=u, file=fname, status='replace')\n  do i = 1, n\n    write(u, *) arr(i)\n  end do\n  close(u)\nend subroutine write_array_to_file",
        "summary": "Writes the elements of a real array to a file, with each element on a new line."
    },
    {
        "id": 11,
        "code": "program read_integers\n  implicit none\n  integer :: val, u, ios\n  open(newunit=u, file='numbers.txt', status='old')\n  do\n    read(u, *, iostat=ios) val\n    if (ios /= 0) exit\n    print *, 'Read:', val\n  end do\n  close(u)\nend program read_integers",
        "summary": "Reads integer values from 'numbers.txt' one by one and prints them."
    },
    {
        "id": 12,
        "code": "function get_file_size(filename) result(sz)\n  implicit none\n  character(len=*), intent(in) :: filename\n  integer :: sz\n  inquire(file=filename, size=sz)\nend function get_file_size",
        "summary": "Returns the size of the specified file in file storage units (bytes)."
    },
    {
        "id": 13,
        "code": "program merge_files\n  implicit none\n  integer :: u1, u2, u3, ios\n  character(len=100) :: line\n  open(newunit=u3, file='merged.txt', status='replace')\n  open(newunit=u1, file='part1.txt', status='old')\n  do\n    read(u1, '(A)', iostat=ios) line\n    if (ios /= 0) exit\n    write(u3, '(A)') trim(line)\n  end do\n  close(u1)\n  open(newunit=u2, file='part2.txt', status='old')\n  do\n    read(u2, '(A)', iostat=ios) line\n    if (ios /= 0) exit\n    write(u3, '(A)') trim(line)\n  end do\n  close(u2)\n  close(u3)\nend program merge_files",
        "summary": "Merges the contents of 'part1.txt' and 'part2.txt' into a new file named 'merged.txt'."
    },
    {
        "id": 14,
        "code": "subroutine log_message(msg)\n  implicit none\n  character(len=*), intent(in) :: msg\n  integer :: u\n  open(newunit=u, file='system.log', position='append', status='unknown')\n  write(u, '(A)') trim(msg)\n  close(u)\nend subroutine log_message",
        "summary": "Appends a specific message string to the 'system.log' file."
    },
    {
        "id": 15,
        "code": "program check_open\n  implicit none\n  logical :: is_open\n  inquire(unit=10, opened=is_open)\n  if (is_open) then\n    print *, 'Unit 10 is open'\n  else\n    print *, 'Unit 10 is closed'\n  end if\nend program check_open",
        "summary": "Checks if file unit number 10 is currently open and prints the status."
    },
    {
        "id": 16,
        "code": "subroutine skip_header(u)\n  implicit none\n  integer, intent(in) :: u\n  read(u, *) ! Skip line\nend subroutine skip_header",
        "summary": "Skips the first line of an open file unit, commonly used to bypass CSV headers."
    },
    {
        "id": 17,
        "code": "program read_matrix\n  implicit none\n  integer :: u, i, j\n  real :: mat(3,3)\n  open(newunit=u, file='matrix.dat', status='old')\n  read(u, *) ((mat(i,j), j=1,3), i=1,3)\n  close(u)\nend program read_matrix",
        "summary": "Reads a 3x3 matrix of real numbers from 'matrix.dat'."
    },
    {
        "id": 18,
        "code": "function is_file_readable(fname) result(readable)\n  implicit none\n  character(len=*), intent(in) :: fname\n  logical :: readable\n  inquire(file=fname, read=readable)\nend function is_file_readable",
        "summary": "Determines if the specified file has read permissions."
    },
    {
        "id": 19,
        "code": "program write_csv\n  implicit none\n  integer :: u\n  open(newunit=u, file='data.csv', status='replace')\n  write(u, '(A,A,A)') 'ID', ',', 'Value'\n  write(u, '(I0,A,F5.2)') 1, ',', 3.14\n  close(u)\nend program write_csv",
        "summary": "Writes a simple CSV file with a header and one data row."
    },
    {
        "id": 20,
        "code": "subroutine count_words(fname, count)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(out) :: count\n  integer :: u, ios\n  character(len=100) :: word\n  count = 0\n  open(newunit=u, file=fname, status='old')\n  do\n    read(u, *, iostat=ios) word\n    if (ios /= 0) exit\n    count = count + 1\n  end do\n  close(u)\nend subroutine count_words",
        "summary": "Counts the number of whitespace-separated words in a file."
    },
    {
        "id": 21,
        "code": "program file_copy_lines\n  implicit none\n  integer :: u_in, u_out, ios\n  character(len=200) :: line\n  open(newunit=u_in, file='input.txt', status='old')\n  open(newunit=u_out, file='output.txt', status='replace')\n  do\n    read(u_in, '(A)', iostat=ios) line\n    if (ios /= 0) exit\n    write(u_out, '(A)') trim(line)\n  end do\n  close(u_in)\n  close(u_out)\nend program file_copy_lines",
        "summary": "Copies contents from 'input.txt' to 'output.txt' line by line."
    },
    {
        "id": 22,
        "code": "subroutine empty_file(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer :: u\n  open(newunit=u, file=fname, status='replace')\n  close(u)\nend subroutine empty_file",
        "summary": "Creates an empty file or truncates an existing file to zero length."
    },
    {
        "id": 23,
        "code": "program read_fixed_width\n  implicit none\n  integer :: u, id\n  character(len=10) :: name\n  open(newunit=u, file='fixed.dat', status='old')\n  read(u, '(I5,A10)') id, name\n  print *, id, name\n  close(u)\nend program read_fixed_width",
        "summary": "Reads data from a fixed-width format file using a formatted read statement."
    },
    {
        "id": 24,
        "code": "function count_records(fname, rec_len) result(n)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(in) :: rec_len\n  integer :: n, sz\n  inquire(file=fname, size=sz)\n  n = sz / rec_len\nend function count_records",
        "summary": "Estimates the number of records in a file based on file size and fixed record length."
    },
    {
        "id": 25,
        "code": "program list_file_properties\n  implicit none\n  character(len=20) :: fname = 'test.txt'\n  logical :: ex, op\n  integer :: sz\n  inquire(file=fname, exist=ex, opened=op, size=sz)\n  print *, 'Exists:', ex, 'Opened:', op, 'Size:', sz\nend program list_file_properties",
        "summary": "Prints existence, open status, and size properties of 'test.txt'."
    },
    {
        "id": 26,
        "code": "subroutine write_error(msg)\n  implicit none\n  character(len=*), intent(in) :: msg\n  write(0, *) 'ERROR: ', trim(msg)\nend subroutine write_error",
        "summary": "Writes an error message to the standard error unit (unit 0)."
    },
    {
        "id": 27,
        "code": "program binary_write\n  implicit none\n  integer :: u\n  real :: x = 1.234\n  open(newunit=u, file='bin.dat', form='unformatted', status='replace')\n  write(u) x\n  close(u)\nend program binary_write",
        "summary": "Writes a real number to a file in binary (unformatted) format."
    },
    {
        "id": 28,
        "code": "program binary_read\n  implicit none\n  integer :: u\n  real :: x\n  open(newunit=u, file='bin.dat', form='unformatted', status='old')\n  read(u) x\n  print *, x\n  close(u)\nend program binary_read",
        "summary": "Reads a real number from a binary (unformatted) file."
    },
    {
        "id": 29,
        "code": "subroutine print_file(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer :: u, ios\n  character(len=100) :: line\n  open(newunit=u, file=fname, status='old', iostat=ios)\n  if (ios == 0) then\n    do\n      read(u, '(A)', iostat=ios) line\n      if (ios /= 0) exit\n      print *, trim(line)\n    end do\n    close(u)\n  end if\nend subroutine print_file",
        "summary": "Prints the entire contents of a file to standard output."
    },
    {
        "id": 30,
        "code": "program temp_file\n  implicit none\n  integer :: u\n  open(newunit=u, status='scratch')\n  write(u, *) 'Temporary data'\n  close(u)\nend program temp_file",
        "summary": "Creates a temporary scratch file that is automatically deleted when closed."
    },
    {
        "id": 31,
        "code": "function get_io_status(fname) result(ios)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer :: ios, u\n  open(newunit=u, file=fname, status='old', iostat=ios)\n  if (ios == 0) close(u)\nend function get_io_status",
        "summary": "Attempts to open a file and returns the I/O status code (0 for success)."
    },
    {
        "id": 32,
        "code": "program read_nml\n  implicit none\n  integer :: u, a, b\n  namelist /params/ a, b\n  open(newunit=u, file='input.nml', status='old')\n  read(u, nml=params)\n  print *, a, b\n  close(u)\nend program read_nml",
        "summary": "Reads variables 'a' and 'b' from a Fortran namelist file 'input.nml'."
    },
    {
        "id": 33,
        "code": "program write_nml\n  implicit none\n  integer :: u, a=10, b=20\n  namelist /params/ a, b\n  open(newunit=u, file='output.nml', status='replace')\n  write(u, nml=params)\n  close(u)\nend program write_nml",
        "summary": "Writes variables 'a' and 'b' to a file in Fortran namelist format."
    },
    {
        "id": 34,
        "code": "subroutine backup_file(src, bak)\n  implicit none\n  character(len=*), intent(in) :: src, bak\n  character(len=1024) :: cmd\n  call execute_command_line('cp ' // src // ' ' // bak)\nend subroutine backup_file",
        "summary": "Backs up a file by executing a system shell command to copy it."
    },
    {
        "id": 35,
        "code": "program read_specific_line\n  implicit none\n  integer :: u, i, target=5\n  character(len=100) :: line\n  open(newunit=u, file='data.txt', status='old')\n  do i = 1, target\n    read(u, '(A)') line\n  end do\n  print *, trim(line)\n  close(u)\nend program read_specific_line",
        "summary": "Reads and prints the 5th line of 'data.txt'."
    },
    {
        "id": 36,
        "code": "subroutine file_to_upper(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  ! Implementation would require reading, converting, writing\n  ! This snippet is a placeholder for logic structure\nend subroutine file_to_upper",
        "summary": "Placeholder subroutine structure for converting file content to uppercase."
    },
    {
        "id": 37,
        "code": "program check_write_access\n  implicit none\n  character(len=20) :: f = 'test.dat'\n  logical :: rw\n  inquire(file=f, write=rw)\n  if (rw) print *, 'Write access granted'\nend program check_write_access",
        "summary": "Checks if the program has write access to 'test.dat'."
    },
    {
        "id": 38,
        "code": "subroutine close_if_open(u)\n  implicit none\n  integer, intent(in) :: u\n  logical :: op\n  inquire(unit=u, opened=op)\n  if (op) close(u)\nend subroutine close_if_open",
        "summary": "Checks if a unit is open and closes it if true, preventing errors from closing closed units."
    },
    {
        "id": 39,
        "code": "program rewind_file\n  implicit none\n  integer :: u\n  character(len=10) :: buf\n  open(newunit=u, file='data.txt', status='old')\n  read(u, *) buf\n  rewind(u)\n  read(u, *) buf\n  close(u)\nend program rewind_file",
        "summary": "Reads from a file, rewinds to the beginning, and reads the first item again."
    },
    {
        "id": 40,
        "code": "subroutine append_newline(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer :: u\n  open(newunit=u, file=fname, position='append')\n  write(u, *) \n  close(u)\nend subroutine append_newline",
        "summary": "Appends a newline character to the end of the specified file."
    },
    {
        "id": 41,
        "code": "program direct_access_read\n  implicit none\n  integer :: u, rec_num, val\n  open(newunit=u, file='direct.dat', access='direct', recl=4, status='old')\n  read(u, rec=3) val\n  print *, 'Record 3:', val\n  close(u)\nend program direct_access_read",
        "summary": "Reads the 3rd record from a direct access file with a record length of 4 bytes."
    },
    {
        "id": 42,
        "code": "program direct_access_write\n  implicit none\n  integer :: u\n  open(newunit=u, file='direct.dat', access='direct', recl=4, status='replace')\n  write(u, rec=1) 10\n  write(u, rec=2) 20\n  close(u)\nend program direct_access_write",
        "summary": "Writes integers to specific records in a direct access file."
    },
    {
        "id": 43,
        "code": "subroutine set_position_begin(u)\n  implicit none\n  integer, intent(in) :: u\n  rewind(u)\nend subroutine set_position_begin",
        "summary": "Rewinds the file pointer of a given unit to the beginning of the file."
    },
    {
        "id": 44,
        "code": "program check_formatted\n  implicit none\n  character(len=10) :: fmt\n  inquire(file='data.txt', formatted=fmt)\n  print *, 'Formatted: ', fmt\nend program check_formatted",
        "summary": "Checks and prints whether 'data.txt' is formatted, unformatted, or unknown."
    },
    {
        "id": 45,
        "code": "subroutine read_ignore_error(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer :: u\n  open(newunit=u, file=fname, status='old', iostat=*, err=100)\n  read(u, *)\n  close(u)\n  return\n100 print *, 'Error ignored'\nend subroutine read_ignore_error",
        "summary": "Attempts to read a file and jumps to a label to handle errors gracefully."
    },
    {
        "id": 46,
        "code": "program read_internal\n  implicit none\n  character(len=20) :: buffer = '123 456'\n  integer :: a, b\n  read(buffer, *) a, b\n  print *, a + b\nend program read_internal",
        "summary": "Performs an internal read from a string variable to extract two integers."
    },
    {
        "id": 47,
        "code": "program write_internal\n  implicit none\n  character(len=50) :: buffer\n  integer :: res = 42\n  write(buffer, '(A,I0)') 'Result is ', res\n  print *, trim(buffer)\nend program write_internal",
        "summary": "Performs an internal write to format an integer into a string variable."
    },
    {
        "id": 48,
        "code": "subroutine flush_buffer(u)\n  implicit none\n  integer, intent(in) :: u\n  flush(u)\nend subroutine flush_buffer",
        "summary": "Flushes the I/O buffer for the specified unit to ensure data is written to disk."
    },
    {
        "id": 49,
        "code": "program backspace_file\n  implicit none\n  integer :: u\n  open(newunit=u, file='data.txt')\n  read(u, *)\n  backspace(u)\n  read(u, *)\n  close(u)\nend program backspace_file",
        "summary": "Reads a record, moves back to the previous record using backspace, and reads it again."
    },
    {
        "id": 50,
        "code": "function get_unit_number() result(u)\n  implicit none\n  integer :: u\n  logical :: op\n  do u = 10, 99\n    inquire(unit=u, opened=op)\n    if (.not. op) return\n  end do\n  u = -1\nend function get_unit_number",
        "summary": "Finds and returns a free unit number between 10 and 99."
    },
    {
        "id": 51,
        "code": "program read_end_of_file\n  implicit none\n  integer :: u, val, ios\n  open(newunit=u, file='data.txt')\n  do\n    read(u, *, iostat=ios) val\n    if (is_iostat_end(ios)) exit\n  end do\n  close(u)\nend program read_end_of_file",
        "summary": "Reads a file until the standard intrinsic `is_iostat_end` detects the end of file."
    },
    {
        "id": 52,
        "code": "subroutine readline_to_buffer(u, buf)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(out) :: buf\n  read(u, '(A)') buf\nend subroutine readline_to_buffer",
        "summary": "Reads a single line of text from a unit into a character buffer."
    },
    {
        "id": 53,
        "code": "program check_action\n  implicit none\n  character(len=20) :: act\n  inquire(unit=10, action=act)\n  print *, 'Action allowed: ', act\nend program check_action",
        "summary": "Inquires the allowed action (READ, WRITE, or READWRITE) for unit 10."
    },
    {
        "id": 54,
        "code": "subroutine force_create(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer :: u\n  open(newunit=u, file=fname, status='unknown')\n  close(u)\nend subroutine force_create",
        "summary": "Ensures a file exists by opening it with status 'unknown' and immediately closing it."
    },
    {
        "id": 55,
        "code": "program read_allocatable_string\n  implicit none\n  integer :: u\n  character(len=:), allocatable :: str\n  character(len=100) :: temp\n  open(newunit=u, file='text.txt')\n  read(u, '(A)') temp\n  str = trim(temp)\n  close(u)\nend program read_allocatable_string",
        "summary": "Reads text into a fixed buffer and assigns it to an allocatable string."
    },
    {
        "id": 56,
        "code": "subroutine print_error_and_stop(msg)\n  implicit none\n  character(len=*), intent(in) :: msg\n  print *, 'Fatal Error: ', msg\n  stop 1\nend subroutine print_error_and_stop",
        "summary": "Prints a fatal error message and terminates the program execution."
    },
    {
        "id": 57,
        "code": "program read_lines_array\n  implicit none\n  character(len=50), dimension(10) :: lines\n  integer :: u\n  open(newunit=u, file='lines.txt')\n  read(u, '(A)') lines\n  close(u)\nend program read_lines_array",
        "summary": "Reads up to 10 lines from 'lines.txt' directly into an array of strings."
    },
    {
        "id": 58,
        "code": "function file_is_open(fname) result(is_open)\n  implicit none\n  character(len=*), intent(in) :: fname\n  logical :: is_open\n  inquire(file=fname, opened=is_open)\nend function file_is_open",
        "summary": "Checks if a file with the given name is currently connected to a unit (open)."
    },
    {
        "id": 59,
        "code": "program write_tab_delimited\n  implicit none\n  integer :: u\n  open(newunit=u, file='out.tsv')\n  write(u, '(A, A, A)') 'Col1', char(9), 'Col2'\n  close(u)\nend program write_tab_delimited",
        "summary": "Writes a tab-delimited header row to 'out.tsv' using the ASCII tab character."
    },
    {
        "id": 60,
        "code": "subroutine wait_for_input(u)\n  implicit none\n  integer, intent(in) :: u\n  wait(u)\nend subroutine wait_for_input",
        "summary": "Performs a wait operation on an asynchronous I/O unit."
    },
    {
        "id": 61,
        "code": "program read_complex\n  implicit none\n  complex :: c\n  integer :: u\n  open(newunit=u, file='complex.dat')\n  read(u, *) c\n  print *, c\n  close(u)\nend program read_complex",
        "summary": "Reads a complex number from a file."
    },
    {
        "id": 62,
        "code": "subroutine copy_n_lines(src, dst, n)\n  implicit none\n  character(len=*), intent(in) :: src, dst\n  integer, intent(in) :: n\n  integer :: u1, u2, i\n  character(len=256) :: line\n  open(newunit=u1, file=src, status='old')\n  open(newunit=u2, file=dst, status='replace')\n  do i = 1, n\n    read(u1, '(A)', end=10) line\n    write(u2, '(A)') trim(line)\n  end do\n10 close(u1)\n  close(u2)\nend subroutine copy_n_lines",
        "summary": "Copies the first N lines from a source file to a destination file."
    },
    {
        "id": 63,
        "code": "program check_access_mode\n  implicit none\n  character(len=20) :: acc\n  inquire(file='data.dat', access=acc)\n  print *, 'Access mode: ', acc\nend program check_access_mode",
        "summary": "Inquires the access mode (SEQUENTIAL or DIRECT) of 'data.dat'."
    },
    {
        "id": 64,
        "code": "subroutine safe_open_read(u, fname, status)\n  implicit none\n  integer, intent(out) :: u, status\n  character(len=*), intent(in) :: fname\n  open(newunit=u, file=fname, status='old', action='read', iostat=status)\nend subroutine safe_open_read",
        "summary": "Safely attempts to open a file for reading and returns the status code."
    },
    {
        "id": 65,
        "code": "program skip_lines\n  implicit none\n  integer :: u, i\n  open(newunit=u, file='data.txt')\n  do i = 1, 5\n    read(u, *)\n  end do\n  print *, 'Skipped 5 lines'\n  close(u)\nend program skip_lines",
        "summary": "Reads and discards the first 5 lines of a file."
    },
    {
        "id": 66,
        "code": "subroutine pad_file(fname, n)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(in) :: n\n  integer :: u, i\n  open(newunit=u, file=fname, position='append')\n  do i = 1, n\n    write(u, *) \n  end do\n  close(u)\nend subroutine pad_file",
        "summary": "Appends N blank lines to the end of the specified file."
    },
    {
        "id": 67,
        "code": "program read_until_keyword\n  implicit none\n  integer :: u\n  character(len=100) :: line\n  open(newunit=u, file='config.txt')\n  do\n    read(u, '(A)') line\n    if (index(line, 'START') > 0) exit\n  end do\n  print *, 'Found START'\n  close(u)\nend program read_until_keyword",
        "summary": "Reads lines from a file until a line containing the keyword 'START' is found."
    },
    {
        "id": 68,
        "code": "function get_line_count(fname) result(n)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer :: n, u, ios\n  n = 0\n  open(newunit=u, file=fname, status='old', iostat=ios)\n  if (ios /= 0) return\n  do\n    read(u, *, iostat=ios)\n    if (ios /= 0) exit\n    n = n + 1\n  end do\n  close(u)\nend function get_line_count",
        "summary": "Counts lines in a file, returning 0 if the file cannot be opened."
    },
    {
        "id": 69,
        "code": "program standard_input\n  implicit none\n  integer :: val\n  print *, 'Enter a number:'\n  read(5, *) val\n  print *, 'You entered:', val\nend program standard_input",
        "summary": "Reads an integer from standard input (unit 5) and prints it."
    },
    {
        "id": 70,
        "code": "program standard_output\n  implicit none\n  write(6, *) 'This goes to stdout'\nend program standard_output",
        "summary": "Writes a message to standard output (unit 6)."
    },
    {
        "id": 71,
        "code": "subroutine close_delete(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u, status='delete')\nend subroutine close_delete",
        "summary": "Closes a unit and deletes the associated file."
    },
    {
        "id": 72,
        "code": "program read_logical\n  implicit none\n  logical :: flag\n  integer :: u\n  open(newunit=u, file='flags.dat')\n  read(u, *) flag\n  close(u)\nend program read_logical",
        "summary": "Reads a logical value (T/F) from a file."
    },
    {
        "id": 73,
        "code": "subroutine rewind_unit(u)\n  implicit none\n  integer, intent(in) :: u\n  rewind(u)\nend subroutine rewind_unit",
        "summary": "Resets the file position of the specified unit to the start."
    },
    {
        "id": 74,
        "code": "program inquire_name\n  implicit none\n  character(len=256) :: name\n  inquire(unit=10, name=name)\n  print *, 'Filename for unit 10:', trim(name)\nend program inquire_name",
        "summary": "Retrieves and prints the filename associated with unit 10."
    },
    {
        "id": 75,
        "code": "subroutine advance_no(u, txt)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: txt\n  write(u, '(A)', advance='no') txt\nend subroutine advance_no",
        "summary": "Writes text to a unit without advancing to the next line (no newline)."
    },
    {
        "id": 76,
        "code": "program read_eor\n  implicit none\n  integer :: u, val, ios\n  open(newunit=u, file='data.txt', pad='no')\n  read(u, '(I5)', advance='no', eor=10, iostat=ios) val\n  print *, val\n  stop\n10 print *, 'End of record hit'\nend program read_eor",
        "summary": "Reads an integer with non-advancing I/O, handling the End-Of-Record condition."
    },
    {
        "id": 77,
        "code": "subroutine set_recl(u, len)\n  implicit none\n  integer, intent(in) :: u, len\n  ! RECL is set during OPEN, cannot be changed on open unit\n  ! This acts as a placeholder for OPEN logic\nend subroutine set_recl",
        "summary": "Placeholder noting that RECL must be set during the OPEN statement."
    },
    {
        "id": 78,
        "code": "program read_doubles\n  implicit none\n  double precision :: d\n  integer :: u\n  open(newunit=u, file='doubles.txt')\n  read(u, *) d\n  close(u)\nend program read_doubles",
        "summary": "Reads a double precision number from 'doubles.txt'."
    },
    {
        "id": 79,
        "code": "subroutine check_error(ios)\n  implicit none\n  integer, intent(in) :: ios\n  if (ios /= 0) print *, 'I/O Error detected'\nend subroutine check_error",
        "summary": "Checks an I/O status variable and prints a message if an error occurred."
    },
    {
        "id": 80,
        "code": "program preconnect_units\n  implicit none\n  write(*, *) 'Asterisk usually maps to unit 6'\nend program preconnect_units",
        "summary": "Demonstrates writing to the default preconnected output unit using an asterisk."
    },
    {
        "id": 81,
        "code": "subroutine read_part(fname, start, end)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(in) :: start, end\n  integer :: u, i\n  character(len=100) :: line\n  open(newunit=u, file=fname)\n  do i = 1, end\n    read(u, '(A)') line\n    if (i >= start) print *, trim(line)\n  end do\n  close(u)\nend subroutine read_part",
        "summary": "Reads lines from a file and prints only those between the start and end indices."
    },
    {
        "id": 82,
        "code": "program write_append_new\n  implicit none\n  integer :: u\n  open(newunit=u, file='notes.txt', position='append')\n  write(u, *) 'New Note'\n  close(u)\nend program write_append_new",
        "summary": "Opens 'notes.txt' and appends 'New Note' to it."
    },
    {
        "id": 83,
        "code": "function is_connected(u) result(conn)\n  implicit none\n  integer, intent(in) :: u\n  logical :: conn\n  inquire(unit=u, opened=conn)\nend function is_connected",
        "summary": "Checks if a specific unit number is currently connected (open)."
    },
    {
        "id": 84,
        "code": "program list_direct_access\n  implicit none\n  integer :: u, i, val\n  open(newunit=u, file='d.dat', access='direct', recl=4)\n  do i = 1, 5\n    read(u, rec=i) val\n    print *, i, val\n  end do\n  close(u)\nend program list_direct_access",
        "summary": "Reads and prints the first 5 records of a direct access file."
    },
    {
        "id": 85,
        "code": "subroutine write_title(u, title)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: title\n  write(u, '(A)') trim(title)\n  write(u, '(A)') repeat('-', len_trim(title))\nend subroutine write_title",
        "summary": "Writes a title string followed by a matching underline of dashes to a unit."
    },
    {
        "id": 86,
        "code": "program read_comma_delimited\n  implicit none\n  integer :: u, a, b\n  open(newunit=u, file='pairs.csv')\n  read(u, *) a, b\n  print *, a, b\n  close(u)\nend program read_comma_delimited",
        "summary": "Reads two comma-separated integers from a CSV file using list-directed input."
    },
    {
        "id": 87,
        "code": "subroutine close_keep(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u, status='keep')\nend subroutine close_keep",
        "summary": "Closes a file unit while explicitly ensuring the file is kept (not deleted)."
    },
    {
        "id": 88,
        "code": "program formatted_read_example\n  implicit none\n  character(len=8) :: date\n  integer :: u\n  open(newunit=u, file='date.txt')\n  read(u, '(A8)') date\n  print *, 'Date read: ', date\n  close(u)\nend program formatted_read_example",
        "summary": "Reads exactly 8 characters from a file into a string variable."
    },
    {
        "id": 89,
        "code": "subroutine skip_record(u)\n  implicit none\n  integer, intent(in) :: u\n  read(u, *) \nend subroutine skip_record",
        "summary": "Reads and discards one record from the specified unit."
    },
    {
        "id": 90,
        "code": "program check_sequential\n  implicit none\n  character(len=20) :: seq\n  inquire(file='data.txt', sequential=seq)\n  print *, 'Sequential access: ', seq\nend program check_sequential",
        "summary": "Checks if sequential access is allowed for 'data.txt'."
    },
    {
        "id": 91,
        "code": "subroutine write_prompt(msg)\n  implicit none\n  character(len=*), intent(in) :: msg\n  write(*, '(A)', advance='no') msg\nend subroutine write_prompt",
        "summary": "Writes a prompt message to standard output without a trailing newline."
    },
    {
        "id": 92,
        "code": "program read_into_matrix\n  implicit none\n  real, allocatable :: mat(:,:)\n  integer :: u, rows, cols\n  open(newunit=u, file='dims.txt')\n  read(u, *) rows, cols\n  allocate(mat(rows, cols))\n  read(u, *) mat\n  close(u)\nend program read_into_matrix",
        "summary": "Reads dimensions from a file, allocates a matrix, and reads data into it."
    },
    {
        "id": 93,
        "code": "function get_fullname(unit) result(name)\n  implicit none\n  integer, intent(in) :: unit\n  character(len=1024) :: name\n  inquire(unit=unit, name=name)\nend function get_fullname",
        "summary": "Returns the full file path/name connected to a given unit."
    },
    {
        "id": 94,
        "code": "program copy_structure\n  implicit none\n  type point\n    real :: x, y\n  end type point\n  type(point) :: p\n  integer :: u1, u2\n  open(newunit=u1, file='p_in.dat', form='unformatted')\n  open(newunit=u2, file='p_out.dat', form='unformatted')\n  read(u1) p\n  write(u2) p\n  close(u1)\n  close(u2)\nend program copy_structure",
        "summary": "Copies a derived type structure from one binary file to another."
    },
    {
        "id": 95,
        "code": "subroutine handle_missing(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  logical :: ex\n  inquire(file=fname, exist=ex)\n  if (.not. ex) then\n    print *, 'File missing, creating empty.'\n    call empty_file(fname)\n  end if\nend subroutine handle_missing",
        "summary": "Checks if a file exists; if not, creates an empty one using `empty_file`."
    },
    {
        "id": 96,
        "code": "program read_error_label\n  implicit none\n  integer :: u\n  open(newunit=u, file='bad.txt', err=20)\n  ! read operations\n  close(u)\n  stop\n20 print *, 'Failed to open file'\nend program read_error_label",
        "summary": "Uses the `err` label in the `open` statement to handle file opening failures."
    },
    {
        "id": 97,
        "code": "subroutine print_dashes(n)\n  implicit none\n  integer, intent(in) :: n\n  write(*, '(100(\"-\"))')\nend subroutine print_dashes",
        "summary": "Prints a line of dashes to standard output (simplified for example)."
    },
    {
        "id": 98,
        "code": "program count_records_loop\n  implicit none\n  integer :: u, n\n  open(newunit=u, file='list.txt')\n  n = 0\n  do\n    read(u, *, end=10) \n    n = n + 1\n  end do\n10 print *, n\n  close(u)\nend program count_records_loop",
        "summary": "Counts records in a file using a loop and the `end` label for termination."
    },
    {
        "id": 99,
        "code": "subroutine check_read_write(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  character(len=20) :: rw\n  inquire(file=fname, readwrite=rw)\n  print *, 'Read/Write status: ', rw\nend subroutine check_read_write",
        "summary": "Inquires and prints the read/write status of a file."
    },
    {
        "id": 100,
        "code": "program write_int_array\n  implicit none\n  integer :: u\n  integer, dimension(5) :: arr = [1, 2, 3, 4, 5]\n  open(newunit=u, file='ints.txt')\n  write(u, '(5I3)') arr\n  close(u)\nend program write_int_array",
        "summary": "Writes an integer array to a file using a specific format."
    },
    {
        "id": 101,
        "code": "subroutine move_file_ptr(u, offset)\n  implicit none\n  integer, intent(in) :: u, offset\n  ! Fortran standard stream I/O logic required\n  ! Placeholder for seeking functionality\nend subroutine move_file_ptr",
        "summary": "Placeholder for moving a file pointer, typically requiring stream access."
    },
    {
        "id": 102,
        "code": "program read_with_sign\n  implicit none\n  integer :: u, val\n  open(newunit=u, file='nums.txt')\n  read(u, '(SP, I5)') val\n  print *, val\n  close(u)\nend program read_with_sign",
        "summary": "Reads an integer forcing the processor to process the plus sign if present."
    },
    {
        "id": 103,
        "code": "subroutine ensure_closed(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u)\nend subroutine ensure_closed",
        "summary": "Unconditionally closes a unit."
    },
    {
        "id": 104,
        "code": "program scratch_usage\n  implicit none\n  integer :: u\n  character(len=10) :: temp\n  open(newunit=u, status='scratch')\n  write(u, *) 'temp data'\n  rewind(u)\n  read(u, *) temp\n  close(u)\nend program scratch_usage",
        "summary": "Demonstrates writing to and reading from a temporary scratch file."
    },
    {
        "id": 105,
        "code": "subroutine print_status(u)\n  implicit none\n  integer, intent(in) :: u\n  integer :: ios\n  character(len=100) :: msg\n  inquire(unit=u, iostat=ios, iomsg=msg)\n  if (ios /= 0) print *, trim(msg)\nend subroutine print_status",
        "summary": "Inquires the status of a unit and prints an error message if the inquiry fails."
    },
    {
        "id": 106,
        "code": "program append_date\n  implicit none\n  integer :: u\n  character(len=8) :: d\n  call date_and_time(date=d)\n  open(newunit=u, file='log.txt', position='append')\n  write(u, *) 'Date: ', d\n  close(u)\nend program append_date",
        "summary": "Gets the current date and appends it to 'log.txt'."
    },
    {
        "id": 107,
        "code": "subroutine write_list(fname, list, n)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(in) :: n\n  integer, dimension(n), intent(in) :: list\n  integer :: u\n  open(newunit=u, file=fname)\n  write(u, *) list\n  close(u)\nend subroutine write_list",
        "summary": "Writes a list of integers to a file using list-directed output."
    },
    {
        "id": 108,
        "code": "program file_position\n  implicit none\n  integer :: u\n  character(len=20) :: pos\n  open(newunit=u, file='data.txt', position='append')\n  inquire(unit=u, position=pos)\n  print *, 'Position: ', pos\n  close(u)\nend program file_position",
        "summary": "Opens a file in append mode and inquires its current position."
    },
    {
        "id": 109,
        "code": "subroutine set_blank_null(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, blank='null')\nend subroutine set_blank_null",
        "summary": "Sets the interpretation of blanks in numeric fields to null (ignored) for an open unit."
    },
    {
        "id": 110,
        "code": "program read_stream\n  implicit none\n  integer :: u\n  character :: byte\n  open(newunit=u, file='data.bin', access='stream')\n  read(u) byte\n  print *, byte\n  close(u)\nend program read_stream",
        "summary": "Reads a single byte from a file opened with stream access."
    },
    {
        "id": 111,
        "code": "subroutine close_print(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u)\n  print *, 'File closed.'\nend subroutine close_print",
        "summary": "Closes a file and prints a confirmation message."
    },
    {
        "id": 112,
        "code": "program write_formatted_real\n  implicit none\n  real :: x = 123.456\n  integer :: u\n  open(newunit=u, file='out.txt')\n  write(u, '(F10.2)') x\n  close(u)\nend program write_formatted_real",
        "summary": "Writes a real number to 'out.txt' formatted with 2 decimal places."
    },
    {
        "id": 113,
        "code": "subroutine check_direct(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  character(len=20) :: acc\n  inquire(file=fname, direct=acc)\n  print *, 'Direct access: ', acc\nend subroutine check_direct",
        "summary": "Checks if direct access is allowed for the specified file."
    },
    {
        "id": 114,
        "code": "program read_lines_until_end\n  implicit none\n  integer :: u, ios\n  character(len=80) :: line\n  open(newunit=u, file='text.txt')\n  do\n    read(u, '(A)', iostat=ios) line\n    if (ios < 0) exit ! EOF\n    print *, trim(line)\n  end do\n  close(u)\nend program read_lines_until_end",
        "summary": "Reads lines from 'text.txt' until the End-Of-File (negative IOSTAT) is reached."
    },
    {
        "id": 115,
        "code": "subroutine open_new_replace(fname, u)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(out) :: u\n  open(newunit=u, file=fname, status='replace')\nend subroutine open_new_replace",
        "summary": "Opens a new file for writing, replacing it if it already exists, and returns the unit number."
    },
    {
        "id": 116,
        "code": "program read_partial_record\n  implicit none\n  integer :: u\n  integer :: x\n  open(newunit=u, file='data.txt')\n  read(u, '(I5)', advance='no') x\n  print *, x\n  close(u)\nend program read_partial_record",
        "summary": "Reads an integer from a record without advancing the file pointer to the next record."
    },
    {
        "id": 117,
        "code": "subroutine write_bool(u, b)\n  implicit none\n  integer, intent(in) :: u\n  logical, intent(in) :: b\n  write(u, '(L1)') b\nend subroutine write_bool",
        "summary": "Writes a logical value as a single character (T or F) to a unit."
    },
    {
        "id": 118,
        "code": "program check_unformatted\n  implicit none\n  character(len=20) :: unf\n  inquire(file='bin.dat', unformatted=unf)\n  print *, 'Unformatted I/O: ', unf\nend program check_unformatted",
        "summary": "Checks if unformatted I/O is allowed for 'bin.dat'."
    },
    {
        "id": 119,
        "code": "subroutine delete_if_exists(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  logical :: ex\n  inquire(file=fname, exist=ex)\n  if (ex) call delete_file(fname)\nend subroutine delete_if_exists",
        "summary": "Combines existence check and deletion (helper wrapper)."
    },
    {
        "id": 120,
        "code": "program read_g_format\n  implicit none\n  real :: r\n  integer :: u\n  open(newunit=u, file='data.txt')\n  read(u, '(G10.4)') r\n  print *, r\n  close(u)\nend program read_g_format",
        "summary": "Reads a real number using the generalized edit descriptor G."
    },
    {
        "id": 121,
        "code": "subroutine write_star(val)\n  implicit none\n  integer, intent(in) :: val\n  write(*, *) val\nend subroutine write_star",
        "summary": "Writes an integer to the default output unit using list-directed formatting."
    },
    {
        "id": 122,
        "code": "program inquire_pad\n  implicit none\n  character(len=20) :: pd\n  inquire(unit=10, pad=pd)\n  print *, 'Pad: ', pd\nend program inquire_pad",
        "summary": "Inquires the padding setting (YES/NO) for unit 10."
    },
    {
        "id": 123,
        "code": "subroutine set_decimal_comma(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, decimal='comma')\nend subroutine set_decimal_comma",
        "summary": "Sets the decimal edit mode to comma for the specified open unit."
    },
    {
        "id": 124,
        "code": "program read_with_err_check\n  implicit none\n  integer :: u, val, ios\n  open(newunit=u, file='nums.txt')\n  read(u, *, iostat=ios) val\n  if (ios > 0) print *, 'Read Error'\n  close(u)\nend program read_with_err_check",
        "summary": "Reads a value and specifically checks for a read error (positive IOSTAT)."
    },
    {
        "id": 125,
        "code": "subroutine print_header(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, *) '--- HEADER ---'\nend subroutine print_header",
        "summary": "Writes a simple header line to the given unit."
    },
    {
        "id": 126,
        "code": "program check_delims\n  implicit none\n  character(len=20) :: del\n  inquire(unit=10, delim=del)\n  print *, 'Delimiters: ', del\nend program check_delims",
        "summary": "Inquires the delimiter mode (QUOTE, APOSTROPHE, NONE) for unit 10."
    },
    {
        "id": 127,
        "code": "subroutine write_csv_row(u, a, b)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: a, b\n  write(u, '(A, A, A)') trim(a), ',', trim(b)\nend subroutine write_csv_row",
        "summary": "Writes two string values separated by a comma to a file unit."
    },
    {
        "id": 128,
        "code": "program read_multiple_lines\n  implicit none\n  integer :: u, i\n  character(len=50) :: l\n  open(newunit=u, file='data.txt')\n  do i = 1, 3\n    read(u, '(A)') l\n    print *, trim(l)\n  end do\n  close(u)\nend program read_multiple_lines",
        "summary": "Reads and prints the first 3 lines of 'data.txt'."
    },
    {
        "id": 129,
        "code": "subroutine close_save(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u, status='keep')\nend subroutine close_save",
        "summary": "Closes a unit and saves the file (synonym for keep status)."
    },
    {
        "id": 130,
        "code": "program read_allocatable_array\n  implicit none\n  integer, allocatable :: arr(:)\n  integer :: u, n\n  open(newunit=u, file='arr.txt')\n  read(u, *) n\n  allocate(arr(n))\n  read(u, *) arr\n  close(u)\nend program read_allocatable_array",
        "summary": "Reads array size N, allocates the array, and reads N elements from a file."
    },
    {
        "id": 131,
        "code": "subroutine open_append(fname, u)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(out) :: u\n  open(newunit=u, file=fname, status='old', position='append')\nend subroutine open_append",
        "summary": "Opens an existing file for appending and returns the unit number."
    },
    {
        "id": 132,
        "code": "program character_count_loop\n  implicit none\n  integer :: u, n\n  character :: c\n  integer :: ios\n  open(newunit=u, file='data.txt', access='stream')\n  n = 0\n  do\n    read(u, iostat=ios) c\n    if (ios /= 0) exit\n    n = n + 1\n  end do\n  print *, n\n  close(u)\nend program character_count_loop",
        "summary": "Counts characters in a file using a loop and stream access."
    },
    {
        "id": 133,
        "code": "subroutine write_literal(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, *) 42\nend subroutine write_literal",
        "summary": "Writes the integer literal 42 to the specified unit."
    },
    {
        "id": 134,
        "code": "program check_encoding\n  implicit none\n  character(len=20) :: enc\n  inquire(unit=10, encoding=enc)\n  print *, 'Encoding: ', enc\nend program check_encoding",
        "summary": "Inquires the text encoding (e.g., UTF-8) of unit 10."
    },
    {
        "id": 135,
        "code": "subroutine rewind_and_read(u, val)\n  implicit none\n  integer, intent(in) :: u\n  integer, intent(out) :: val\n  rewind(u)\n  read(u, *) val\nend subroutine rewind_and_read",
        "summary": "Rewinds the unit and reads the first integer value."
    },
    {
        "id": 136,
        "code": "program read_skip_read\n  implicit none\n  integer :: u, v1, v2\n  open(newunit=u, file='nums.txt')\n  read(u, *) v1\n  read(u, *) ! skip\n  read(u, *) v2\n  close(u)\nend program read_skip_read",
        "summary": "Reads a value, skips a record, and reads another value."
    },
    {
        "id": 137,
        "code": "subroutine set_sign_plus(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, sign='plus')\nend subroutine set_sign_plus",
        "summary": "Sets the sign mode to 'plus' for an open unit, forcing output of '+' for positive numbers."
    },
    {
        "id": 138,
        "code": "program read_keyword_value\n  implicit none\n  integer :: u\n  character(len=20) :: key\n  real :: val\n  open(newunit=u, file='cfg.txt')\n  read(u, *) key, val\n  if (trim(key) == 'timeout') print *, val\n  close(u)\nend program read_keyword_value",
        "summary": "Reads a key-value pair and prints the value if the key matches 'timeout'."
    },
    {
        "id": 139,
        "code": "subroutine close_scratch(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u) ! scratch files delete automatically\nend subroutine close_scratch",
        "summary": "Closes a scratch file unit, triggering its deletion."
    },
    {
        "id": 140,
        "code": "program inquire_iolength\n  implicit none\n  integer :: iolen\n  real :: x\n  inquire(iolength=iolen) x\n  print *, 'IO Length for real: ', iolen\nend program inquire_iolength",
        "summary": "Determines the I/O length required for a real variable (used for RECL)."
    },
    {
        "id": 141,
        "code": "subroutine write_blank_line(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, *)\nend subroutine write_blank_line",
        "summary": "Writes a blank line to the specified unit."
    },
    {
        "id": 142,
        "code": "program read_string_var\n  implicit none\n  character(len=20) :: str\n  read(*, '(A)') str\n  print *, 'Input: ', str\nend program read_string_var",
        "summary": "Reads a string from standard input and prints it."
    },
    {
        "id": 143,
        "code": "subroutine open_read_only(fname, u)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(out) :: u\n  open(newunit=u, file=fname, status='old', action='read')\nend subroutine open_read_only",
        "summary": "Opens a file in read-only mode."
    },
    {
        "id": 144,
        "code": "program count_lines_simple\n  implicit none\n  integer :: n\n  call count_lines('data.txt', n)\n  print *, n\nend program count_lines_simple",
        "summary": "Main program calling the `count_lines` subroutine for 'data.txt'."
    },
    {
        "id": 145,
        "code": "subroutine write_version(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)') 'Version 1.0'\nend subroutine write_version",
        "summary": "Writes the version string to the file unit."
    },
    {
        "id": 146,
        "code": "program check_exist_inquire\n  implicit none\n  logical :: ex\n  inquire(file='notes.txt', exist=ex)\n  if (ex) print *, 'Found'\nend program check_exist_inquire",
        "summary": "Checks if 'notes.txt' exists and prints 'Found' if true."
    },
    {
        "id": 147,
        "code": "subroutine set_round_up(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, round='up')\nend subroutine set_round_up",
        "summary": "Sets the rounding mode to 'up' for the specified unit."
    },
    {
        "id": 148,
        "code": "program read_formatted_date\n  implicit none\n  integer :: d, m, y, u\n  open(newunit=u, file='date.dat')\n  read(u, '(I2,1X,I2,1X,I4)') d, m, y\n  print *, y, m, d\n  close(u)\nend program read_formatted_date",
        "summary": "Reads a date in DD MM YYYY format and prints it as YYYY MM DD."
    },
    {
        "id": 149,
        "code": "subroutine write_timestamp(u)\n  implicit none\n  integer, intent(in) :: u\n  character(len=8) :: d\n  character(len=10) :: t\n  call date_and_time(date=d, time=t)\n  write(u, '(A,1X,A)') d, t\nend subroutine write_timestamp",
        "summary": "Writes the current date and time to the specified unit."
    },
    {
        "id": 150,
        "code": "program check_asynchronous\n  implicit none\n  character(len=20) :: asy\n  inquire(unit=10, asynchronous=asy)\n  print *, 'Async: ', asy\nend program check_asynchronous",
        "summary": "Inquires if asynchronous I/O is allowed for unit 10."
    },
    {
        "id": 151,
        "code": "subroutine backspace_record(u)\n  implicit none\n  integer, intent(in) :: u\n  backspace(u)\nend subroutine backspace_record",
        "summary": "Moves the file position back by one record."
    },
    {
        "id": 152,
        "code": "program read_with_size\n  implicit none\n  integer :: u, sz\n  character(len=100) :: buf\n  open(newunit=u, file='data.txt', access='stream')\n  read(u) buf\n  inquire(unit=u, pos=sz)\n  print *, 'Position:', sz\n  close(u)\nend program read_with_size",
        "summary": "Reads from a stream file and inquires the current file position."
    },
    {
        "id": 153,
        "code": "subroutine set_recl_64(u)\n  implicit none\n  integer, intent(in) :: u\n  ! Pseudo-code: RECL usually set at open\n  ! open(unit=u, recl=64)\nend subroutine set_recl_64",
        "summary": "Concept subroutine for setting record length to 64 bytes."
    },
    {
        "id": 154,
        "code": "program read_to_eof\n  implicit none\n  integer :: u, ios\n  character :: c\n  open(newunit=u, file='data.txt')\n  do\n    read(u, '(A)', iostat=ios) c\n    if (ios /= 0) exit\n  end do\n  close(u)\nend program read_to_eof",
        "summary": "Reads a file character by character until EOF."
    },
    {
        "id": 155,
        "code": "subroutine write_separator(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)') '===================='\nend subroutine write_separator",
        "summary": "Writes a separator line of equals signs to the file."
    },
    {
        "id": 156,
        "code": "program check_read_only\n  implicit none\n  character(len=20) :: act\n  inquire(file='data.txt', action=act)\n  if (trim(act) == 'READ') print *, 'Read only'\nend program check_read_only",
        "summary": "Checks if 'data.txt' is opened in read-only mode."
    },
    {
        "id": 157,
        "code": "subroutine newline(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, *) \nend subroutine newline",
        "summary": "Writes a newline to the given unit."
    },
    {
        "id": 158,
        "code": "program read_list_integers\n  implicit none\n  integer :: u\n  integer :: i(5)\n  open(newunit=u, file='list.txt')\n  read(u, *) i\n  print *, i\n  close(u)\nend program read_list_integers",
        "summary": "Reads 5 integers into an array using list-directed input."
    },
    {
        "id": 159,
        "code": "subroutine check_open_status(u, op)\n  implicit none\n  integer, intent(in) :: u\n  logical, intent(out) :: op\n  inquire(unit=u, opened=op)\nend subroutine check_open_status",
        "summary": "Returns the open status of a unit as a logical value."
    },
    {
        "id": 160,
        "code": "program write_formatted_int\n  implicit none\n  integer :: u, val=123\n  open(newunit=u, file='out.txt')\n  write(u, '(I5.5)') val\n  close(u)\nend program write_formatted_int",
        "summary": "Writes an integer with leading zeros (width 5) to a file."
    },
    {
        "id": 161,
        "code": "subroutine rewind_file(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer :: u\n  open(newunit=u, file=fname)\n  rewind(u)\n  close(u)\nend subroutine rewind_file",
        "summary": "Opens a file, rewinds it (resetting position), and closes it."
    },
    {
        "id": 162,
        "code": "program check_size_limit\n  implicit none\n  integer :: sz\n  inquire(file='log.txt', size=sz)\n  if (sz > 1000) print *, 'File too large'\nend program check_size_limit",
        "summary": "Checks if 'log.txt' is larger than 1000 bytes."
    },
    {
        "id": 163,
        "code": "subroutine write_doubles(u, arr)\n  implicit none\n  integer, intent(in) :: u\n  double precision, dimension(:), intent(in) :: arr\n  write(u, *) arr\nend subroutine write_doubles",
        "summary": "Writes an array of double precision numbers to a unit."
    },
    {
        "id": 164,
        "code": "program read_skip_chars\n  implicit none\n  integer :: u\n  character(len=10) :: c\n  open(newunit=u, file='data.txt')\n  read(u, '(5X, A5)') c\n  print *, c\n  close(u)\nend program read_skip_chars",
        "summary": "Reads 5 characters after skipping the first 5 characters of the record."
    },
    {
        "id": 165,
        "code": "subroutine endfile_unit(u)\n  implicit none\n  integer, intent(in) :: u\n  endfile(u)\nend subroutine endfile_unit",
        "summary": "Writes an end-of-file record to the specified unit."
    },
    {
        "id": 166,
        "code": "program check_read_allowed\n  implicit none\n  character(len=20) :: rd\n  inquire(file='data.txt', read=rd)\n  if (rd == 'YES') print *, 'Readable'\nend program check_read_allowed",
        "summary": "Checks if read access is allowed for 'data.txt'."
    },
    {
        "id": 167,
        "code": "subroutine write_string(u, str)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: str\n  write(u, *) trim(str)\nend subroutine write_string",
        "summary": "Writes a trimmed string to the specified unit."
    },
    {
        "id": 168,
        "code": "program read_tab_sep\n  implicit none\n  integer :: u\n  integer :: a, b\n  open(newunit=u, file='tab.txt', delim='none')\n  read(u, *) a, b\n  print *, a, b\n  close(u)\nend program read_tab_sep",
        "summary": "Reads two integers separated by tabs or spaces (list-directed handles standard separators)."
    },
    {
        "id": 169,
        "code": "subroutine set_position_append(u)\n  implicit none\n  integer, intent(in) :: u\n  ! Can't change position of open unit easily, usually done at OPEN\nend subroutine set_position_append",
        "summary": "Placeholder noting position is typically set at OPEN."
    },
    {
        "id": 170,
        "code": "program read_error_status\n  implicit none\n  integer :: u, ios\n  open(newunit=u, file='missing.txt', iostat=ios)\n  if (ios /= 0) print *, 'Open failed, iostat=', ios\nend program read_error_status",
        "summary": "Attempts to open a file and prints the error status code if it fails."
    },
    {
        "id": 171,
        "code": "subroutine close_delete_if_error(u, ios)\n  implicit none\n  integer, intent(in) :: u, ios\n  if (ios /= 0) then\n    close(u, status='delete')\n  else\n    close(u)\n  end if\nend subroutine close_delete_if_error",
        "summary": "Closes a unit, deleting the file if an error status was indicated."
    },
    {
        "id": 172,
        "code": "program write_scientific\n  implicit none\n  real :: x = 0.000123\n  integer :: u\n  open(newunit=u, file='sci.txt')\n  write(u, '(ES10.3)') x\n  close(u)\nend program write_scientific",
        "summary": "Writes a real number in scientific notation (ES format) to a file."
    },
    {
        "id": 173,
        "code": "subroutine check_named(u)\n  implicit none\n  integer, intent(in) :: u\n  logical :: nmd\n  inquire(unit=u, named=nmd)\n  if (nmd) print *, 'Unit is named'\nend subroutine check_named",
        "summary": "Checks if the unit is connected to a named file."
    },
    {
        "id": 174,
        "code": "program read_char_by_char\n  implicit none\n  integer :: u, ios\n  character :: c\n  open(newunit=u, file='data.txt')\n  do\n    read(u, '(A1)', advance='no', iostat=ios) c\n    if (ios /= 0) exit\n    write(*, '(A1)', advance='no') c\n  end do\n  close(u)\nend program read_char_by_char",
        "summary": "Reads and prints a file character by character using non-advancing I/O."
    },
    {
        "id": 175,
        "code": "subroutine set_decimal_point(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, decimal='point')\nend subroutine set_decimal_point",
        "summary": "Sets the decimal edit mode to point for the specified open unit."
    },
    {
        "id": 176,
        "code": "program read_record_len\n  implicit none\n  integer :: rl\n  inquire(file='data.txt', recl=rl)\n  print *, 'Max record length: ', rl\nend program read_record_len",
        "summary": "Inquires the maximum record length for 'data.txt'."
    },
    {
        "id": 177,
        "code": "subroutine write_lines(u, lines, n)\n  implicit none\n  integer, intent(in) :: u, n\n  character(len=*), dimension(n), intent(in) :: lines\n  integer :: i\n  do i = 1, n\n    write(u, '(A)') trim(lines(i))\n  end do\nend subroutine write_lines",
        "summary": "Writes an array of strings as lines to the specified unit."
    },
    {
        "id": 178,
        "code": "program check_write_allow\n  implicit none\n  character(len=20) :: wr\n  inquire(file='data.txt', write=wr)\n  if (wr == 'YES') print *, 'Writable'\nend program check_write_allow",
        "summary": "Checks if write access is allowed for 'data.txt'."
    },
    {
        "id": 179,
        "code": "subroutine flush_unit(u)\n  implicit none\n  integer, intent(in) :: u\n  flush(u)\nend subroutine flush_unit",
        "summary": "Flushes the unit buffer."
    },
    {
        "id": 180,
        "code": "program read_into_buffer\n  implicit none\n  integer :: u\n  character(len=1024) :: buf\n  open(newunit=u, file='large.txt', access='stream')\n  read(u) buf\n  print *, 'First 1024 bytes read'\n  close(u)\nend program read_into_buffer",
        "summary": "Reads the first 1024 bytes of a file into a buffer using stream access."
    },
    {
        "id": 181,
        "code": "subroutine set_sign_suppress(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, sign='suppress')\nend subroutine set_sign_suppress",
        "summary": "Sets the sign mode to 'suppress' (suppressing optional plus signs)."
    },
    {
        "id": 182,
        "code": "program read_namelist_group\n  implicit none\n  integer :: u, x, y\n  namelist /group/ x, y\n  open(newunit=u, file='nml.txt')\n  read(u, nml=group)\n  close(u)\nend program read_namelist_group",
        "summary": "Reads a specific namelist group from a file."
    },
    {
        "id": 183,
        "code": "subroutine write_label(u, lbl)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: lbl\n  write(u, '(\"[\", A, \"]\")') trim(lbl)\nend subroutine write_label",
        "summary": "Writes a label enclosed in brackets to the unit."
    },
    {
        "id": 184,
        "code": "program check_opened\n  implicit none\n  logical :: op\n  inquire(file='data.txt', opened=op)\n  if (op) print *, 'File is open'\nend program check_opened",
        "summary": "Checks if the file 'data.txt' is currently open."
    },
    {
        "id": 185,
        "code": "subroutine rewind_all(units, n)\n  implicit none\n  integer, intent(in) :: n\n  integer, dimension(n), intent(in) :: units\n  integer :: i\n  do i = 1, n\n    rewind(units(i))\n  end do\nend subroutine rewind_all",
        "summary": "Rewinds a list of file units."
    },
    {
        "id": 186,
        "code": "program read_allocatable_vector\n  implicit none\n  real, allocatable :: vec(:)\n  integer :: u, n\n  open(newunit=u, file='vec.txt')\n  read(u, *) n\n  allocate(vec(n))\n  read(u, *) vec\n  close(u)\nend program read_allocatable_vector",
        "summary": "Reads size N and then N real numbers into an allocatable vector."
    },
    {
        "id": 187,
        "code": "subroutine write_matrix(u, mat, n)\n  implicit none\n  integer, intent(in) :: u, n\n  real, dimension(n,n), intent(in) :: mat\n  integer :: i\n  do i = 1, n\n    write(u, *) mat(i, :)\n  end do\nend subroutine write_matrix",
        "summary": "Writes a square matrix to a unit row by row."
    },
    {
        "id": 188,
        "code": "program check_stream_access\n  implicit none\n  character(len=20) :: acc\n  inquire(file='bin.dat', access=acc)\n  if (trim(acc) == 'STREAM') print *, 'Stream access'\nend program check_stream_access",
        "summary": "Checks if the access mode of 'bin.dat' is STREAM."
    },
    {
        "id": 189,
        "code": "subroutine simple_read(fname, val)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(out) :: val\n  integer :: u\n  open(newunit=u, file=fname)\n  read(u, *) val\n  close(u)\nend subroutine simple_read",
        "summary": "Reads a single integer from the specified file."
    },
    {
        "id": 190,
        "code": "program write_header_footer\n  implicit none\n  integer :: u\n  open(newunit=u, file='report.txt')\n  write(u, *) 'Start'\n  write(u, *) 'Data...'\n  write(u, *) 'End'\n  close(u)\nend program write_header_footer",
        "summary": "Writes simple start and end markers surrounding data in a file."
    },
    {
        "id": 191,
        "code": "subroutine skip_n_lines(u, n)\n  implicit none\n  integer, intent(in) :: u, n\n  integer :: i\n  do i = 1, n\n    read(u, *)\n  end do\nend subroutine skip_n_lines",
        "summary": "Skips N lines in the given open unit."
    },
    {
        "id": 192,
        "code": "program read_unknown_length\n  implicit none\n  integer :: u, count\n  integer :: temp\n  integer :: ios\n  count = 0\n  open(newunit=u, file='ints.txt')\n  do\n    read(u, *, iostat=ios) temp\n    if (ios /= 0) exit\n    count = count + 1\n  end do\n  print *, 'Count:', count\n  close(u)\nend program read_unknown_length",
        "summary": "Counts integers in a file without knowing the count beforehand."
    },
    {
        "id": 193,
        "code": "subroutine set_blank_zero(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, blank='zero')\nend subroutine set_blank_zero",
        "summary": "Sets blanks to be interpreted as zeros for numeric input on unit."
    },
    {
        "id": 194,
        "code": "program check_formatted_inquire\n  implicit none\n  character(len=20) :: fmt\n  inquire(unit=10, formatted=fmt)\n  print *, 'Formatted allowed: ', fmt\nend program check_formatted_inquire",
        "summary": "Inquires if formatted I/O is allowed on unit 10."
    },
    {
        "id": 195,
        "code": "subroutine close_print_status(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u)\n  print *, 'Unit', u, 'closed'\nend subroutine close_print_status",
        "summary": "Closes a unit and prints a status message."
    },
    {
        "id": 196,
        "code": "program read_specific_format\n  implicit none\n  integer :: u\n  real :: x\n  open(newunit=u, file='dat.txt')\n  read(u, '(F5.2)') x\n  print *, x\n  close(u)\nend program read_specific_format",
        "summary": "Reads a real number using the fixed F5.2 format."
    },
    {
        "id": 197,
        "code": "subroutine write_comma(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)', advance='no') ','\nend subroutine write_comma",
        "summary": "Writes a comma without a newline."
    },
    {
        "id": 198,
        "code": "program check_direct_allowed\n  implicit none\n  character(len=20) :: dir\n  inquire(file='data.dat', direct=dir)\n  if (dir == 'YES') print *, 'Direct access OK'\nend program check_direct_allowed",
        "summary": "Checks if direct access is allowed for 'data.dat'."
    },
    {
        "id": 199,
        "code": "subroutine write_space(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(1X)', advance='no')\nend subroutine write_space",
        "summary": "Writes a single space character without a newline."
    },
    {
        "id": 200,
        "code": "program read_default_input\n  implicit none\n  integer :: i\n  read *, i\n  print *, 'Read', i\nend program read_default_input",
        "summary": "Reads an integer from the default input unit using default formatting."
    },
    {
        "id": 201,
        "code": "program read_allocate_matrix\n  implicit none\n  integer :: u, n, m, ios\n  real, allocatable :: matrix(:,:)\n  open(newunit=u, file='matrix_data.txt', status='old', action='read', iostat=ios)\n  if (ios == 0) then\n    read(u, *) n, m\n    allocate(matrix(n,m))\n    read(u, *) matrix\n    print *, 'Matrix read successfully'\n    close(u)\n  end if\nend program read_allocate_matrix",
        "summary": "Reads dimensions N and M from a file, allocates a matrix of that size, and reads the matrix data."
    },
    {
        "id": 202,
        "code": "subroutine write_status_log(msg)\n  implicit none\n  character(len=*), intent(in) :: msg\n  integer :: u\n  character(len=8) :: date\n  character(len=10) :: time\n  call date_and_time(date, time)\n  open(newunit=u, file='status.log', position='append')\n  write(u, '(A,1X,A,1X,A)') date, time, trim(msg)\n  close(u)\nend subroutine write_status_log",
        "summary": "Appends a log message prefixed with the current date and time to 'status.log'."
    },
    {
        "id": 203,
        "code": "program check_file_empty\n  implicit none\n  integer :: u, size\n  inquire(file='data.txt', size=size)\n  if (size == 0) then\n    print *, 'File is empty'\n  else\n    print *, 'File is not empty'\n  end if\nend program check_file_empty",
        "summary": "Checks if 'data.txt' has a file size of zero."
    },
    {
        "id": 204,
        "code": "subroutine copy_file_stream(src, dst)\n  implicit none\n  character(len=*), intent(in) :: src, dst\n  integer :: u_in, u_out, ios\n  character :: char_buf\n  open(newunit=u_in, file=src, access='stream', status='old')\n  open(newunit=u_out, file=dst, access='stream', status='replace')\n  do\n    read(u_in, iostat=ios) char_buf\n    if (ios /= 0) exit\n    write(u_out) char_buf\n  end do\n  close(u_in)\n  close(u_out)\nend subroutine copy_file_stream",
        "summary": "Copies a file byte-by-byte from source to destination using stream access."
    },
    {
        "id": 205,
        "code": "program count_lines_loop\n  implicit none\n  integer :: u, count, ios\n  open(newunit=u, file='input.txt', status='old')\n  count = 0\n  do\n    read(u, *, iostat=ios)\n    if (ios /= 0) exit\n    count = count + 1\n  end do\n  print *, 'Total lines:', count\n  close(u)\nend program count_lines_loop",
        "summary": "Counts the number of lines in 'input.txt' by iterating until EOF."
    },
    {
        "id": 206,
        "code": "subroutine write_formatted_table(u, n, x, y)\n  implicit none\n  integer, intent(in) :: u, n\n  real, dimension(n), intent(in) :: x, y\n  integer :: i\n  write(u, '(A10, A10)') 'X', 'Y'\n  do i = 1, n\n    write(u, '(F10.2, F10.2)') x(i), y(i)\n  end do\nend subroutine write_formatted_table",
        "summary": "Writes two arrays as a formatted table with headers to a specific unit."
    },
    {
        "id": 207,
        "code": "program delete_file_example\n  implicit none\n  integer :: u\n  open(newunit=u, file='temp.dat', status='old')\n  close(u, status='delete')\n  print *, 'File deleted'\nend program delete_file_example",
        "summary": "Opens an existing file and immediately closes it with status='delete' to remove it."
    },
    {
        "id": 208,
        "code": "function file_exists_func(fname) result(res)\n  implicit none\n  character(len=*), intent(in) :: fname\n  logical :: res\n  inquire(file=fname, exist=res)\nend function file_exists_func",
        "summary": "Returns .TRUE. if the specified file exists, otherwise .FALSE."
    },
    {
        "id": 209,
        "code": "program read_specific_record\n  implicit none\n  integer :: u, rec_val\n  open(newunit=u, file='direct.dat', access='direct', recl=4, status='old')\n  read(u, rec=5) rec_val\n  print *, 'Record 5:', rec_val\n  close(u)\nend program read_specific_record",
        "summary": "Reads the 5th integer record from a direct access file."
    },
    {
        "id": 210,
        "code": "subroutine append_text_to_file(fname, txt)\n  implicit none\n  character(len=*), intent(in) :: fname, txt\n  integer :: u\n  open(newunit=u, file=fname, position='append', status='old')\n  write(u, '(A)') trim(txt)\n  close(u)\nend subroutine append_text_to_file",
        "summary": "Opens a file in append mode and writes a string to the end of it."
    },
    {
        "id": 211,
        "code": "program binary_dump\n  implicit none\n  integer :: u\n  real :: array(3) = [1.1, 2.2, 3.3]\n  open(newunit=u, file='dump.bin', form='unformatted', access='stream')\n  write(u) array\n  close(u)\nend program binary_dump",
        "summary": "Writes a real array to a binary file using stream access."
    },
    {
        "id": 212,
        "code": "subroutine read_header_data(u, header, n, data)\n  implicit none\n  integer, intent(in) :: u\n  character(len=80), intent(out) :: header\n  integer, intent(out) :: n\n  real, allocatable, intent(out) :: data(:)\n  read(u, '(A)') header\n  read(u, *) n\n  allocate(data(n))\n  read(u, *) data\nend subroutine read_header_data",
        "summary": "Reads a header string, an integer count, and then allocates and reads an array of data."
    },
    {
        "id": 213,
        "code": "program check_permissions\n  implicit none\n  logical :: rd, wr\n  inquire(file='config.cfg', read=rd, write=wr)\n  print *, 'Read:', rd, 'Write:', wr\nend program check_permissions",
        "summary": "Checks and prints the read and write permissions for 'config.cfg' (standard-dependent implementation of inquire)."
    },
    {
        "id": 214,
        "code": "program rename_file_simulated\n  implicit none\n  call execute_command_line('mv old.txt new.txt')\nend program rename_file_simulated",
        "summary": "Simulates renaming a file by executing a shell command."
    },
    {
        "id": 215,
        "code": "subroutine write_error_log(err_code, msg)\n  implicit none\n  integer, intent(in) :: err_code\n  character(len=*), intent(in) :: msg\n  integer :: u\n  open(newunit=u, file='error.log', position='append')\n  write(u, '(I4, 1X, A)') err_code, trim(msg)\n  close(u)\nend subroutine write_error_log",
        "summary": "Appends an error code and message to 'error.log'."
    },
    {
        "id": 216,
        "code": "program skip_header_read\n  implicit none\n  integer :: u, val\n  open(newunit=u, file='data.csv')\n  read(u, *) ! Skip header\n  read(u, *) val\n  print *, val\n  close(u)\nend program skip_header_read",
        "summary": "Skips the first line of a CSV file and reads a value from the second line."
    },
    {
        "id": 217,
        "code": "function get_file_size_bytes(fname) result(sz)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer :: sz\n  inquire(file=fname, size=sz)\nend function get_file_size_bytes",
        "summary": "Returns the size of a file in bytes using the inquire statement."
    },
    {
        "id": 218,
        "code": "program read_namelist\n  implicit none\n  integer :: a, b\n  namelist /config/ a, b\n  integer :: u\n  open(newunit=u, file='input.nml', status='old')\n  read(u, nml=config)\n  print *, 'a=', a, 'b=', b\n  close(u)\nend program read_namelist",
        "summary": "Reads variables 'a' and 'b' from a namelist file 'input.nml'."
    },
    {
        "id": 219,
        "code": "subroutine create_scratch_file(u)\n  implicit none\n  integer, intent(out) :: u\n  open(newunit=u, status='scratch')\nend subroutine create_scratch_file",
        "summary": "Opens a new scratch file (temporary) and returns its unit number."
    },
    {
        "id": 220,
        "code": "program write_fixed_width\n  implicit none\n  integer :: u\n  character(len=10) :: name = 'Fortran'\n  integer :: ver = 90\n  open(newunit=u, file='out.txt')\n  write(u, '(A10, I5)') name, ver\n  close(u)\nend program write_fixed_width",
        "summary": "Writes data in a fixed-width format (10 chars for string, 5 for integer)."
    },
    {
        "id": 221,
        "code": "program check_unit_open\n  implicit none\n  logical :: is_open\n  inquire(unit=10, opened=is_open)\n  if (is_open) print *, 'Unit 10 is connected'\nend program check_unit_open",
        "summary": "Checks if unit number 10 is currently connected to a file."
    },
    {
        "id": 222,
        "code": "subroutine rewind_file_unit(u)\n  implicit none\n  integer, intent(in) :: u\n  rewind(u)\nend subroutine rewind_file_unit",
        "summary": "Rewinds the file connected to the given unit to the beginning."
    },
    {
        "id": 223,
        "code": "program read_until_eof\n  implicit none\n  integer :: u, ios\n  character(len=100) :: line\n  open(newunit=u, file='text.txt')\n  do\n    read(u, '(A)', iostat=ios) line\n    if (ios /= 0) exit\n    print *, trim(line)\n  end do\n  close(u)\nend program read_until_eof",
        "summary": "Reads and prints lines from a text file until End Of File is reached."
    },
    {
        "id": 224,
        "code": "program write_append_mode\n  implicit none\n  integer :: u\n  open(newunit=u, file='log.txt', status='old', position='append')\n  write(u, *) 'New entry'\n  close(u)\nend program write_append_mode",
        "summary": "Opens an existing 'log.txt' and appends a new line to it."
    },
    {
        "id": 225,
        "code": "subroutine close_and_keep(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u, status='keep')\nend subroutine close_and_keep",
        "summary": "Closes a file unit ensuring the file is preserved (not deleted)."
    },
    {
        "id": 226,
        "code": "program read_internal_string\n  implicit none\n  character(len=20) :: str = '123 45.6'\n  integer :: i\n  real :: r\n  read(str, *) i, r\n  print *, i, r\nend program read_internal_string",
        "summary": "Reads an integer and a real number from an internal string variable."
    },
    {
        "id": 227,
        "code": "program write_internal_string\n  implicit none\n  character(len=50) :: buf\n  integer :: val = 42\n  write(buf, '(A, I3)') 'Value: ', val\n  print *, trim(buf)\nend program write_internal_string",
        "summary": "Formats output into a string variable (internal write) instead of a file."
    },
    {
        "id": 228,
        "code": "subroutine flush_output(u)\n  implicit none\n  integer, intent(in) :: u\n  flush(u)\nend subroutine flush_output",
        "summary": "Forces the system to flush the buffer of the specified unit to disk."
    },
    {
        "id": 229,
        "code": "program backspace_example\n  implicit none\n  integer :: u, val\n  open(newunit=u, file='nums.txt')\n  read(u, *) val\n  backspace(u)\n  read(u, *) val\n  print *, 'Read again:', val\n  close(u)\nend program backspace_example",
        "summary": "Reads a value, backspaces to the start of the record, and reads it again."
    },
    {
        "id": 230,
        "code": "function is_file_open(fname) result(opened)\n  implicit none\n  character(len=*), intent(in) :: fname\n  logical :: opened\n  inquire(file=fname, opened=opened)\nend function is_file_open",
        "summary": "Checks if a file with the given name is currently opened by the program."
    },
    {
        "id": 231,
        "code": "program direct_access_write\n  implicit none\n  integer :: u\n  open(newunit=u, file='data.bin', access='direct', recl=4, status='replace')\n  write(u, rec=1) 100\n  write(u, rec=2) 200\n  close(u)\nend program direct_access_write",
        "summary": "Writes integers 100 and 200 to records 1 and 2 of a direct access file."
    },
    {
        "id": 232,
        "code": "subroutine read_n_lines(fname, n)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(in) :: n\n  integer :: u, i\n  character(len=100) :: line\n  open(newunit=u, file=fname, status='old')\n  do i = 1, n\n    read(u, '(A)', end=10) line\n    print *, trim(line)\n  end do\n10 close(u)\nend subroutine read_n_lines",
        "summary": "Reads and prints the first N lines of a file, handling early EOF."
    },
    {
        "id": 233,
        "code": "program inquire_iolength_test\n  implicit none\n  integer :: len\n  real :: x\n  inquire(iolength=len) x\n  print *, 'RECL for real:', len\nend program inquire_iolength_test",
        "summary": "Determines the record length required for unformatted I/O of a real variable."
    },
    {
        "id": 234,
        "code": "subroutine error_handling_open(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer :: u, ios\n  open(newunit=u, file=fname, status='old', iostat=ios)\n  if (ios /= 0) then\n    print *, 'Error opening file: ', ios\n  else\n    print *, 'File opened successfully'\n    close(u)\n  end if\nend subroutine error_handling_open",
        "summary": "Attempts to open a file and prints an error message if the operation fails."
    },
    {
        "id": 235,
        "code": "program read_comma_delimited\n  implicit none\n  integer :: u\n  real :: x, y\n  open(newunit=u, file='data.csv')\n  read(u, *) x, y\n  print *, x, y\n  close(u)\nend program read_comma_delimited",
        "summary": "Reads two real numbers from a CSV file (list-directed read handles commas)."
    },
    {
        "id": 236,
        "code": "subroutine set_decimal_comma(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, decimal='COMMA')\nend subroutine set_decimal_comma",
        "summary": "Changes the decimal separator to a comma for the specified unit."
    },
    {
        "id": 237,
        "code": "program write_stream_char\n  implicit none\n  integer :: u\n  open(newunit=u, file='out.bin', access='stream')\n  write(u) 'A'\n  write(u) 'B'\n  close(u)\nend program write_stream_char",
        "summary": "Writes characters 'A' and 'B' consecutively to a stream file."
    },
    {
        "id": 238,
        "code": "function get_unit_number() result(u)\n  implicit none\n  integer :: u\n  logical :: op\n  do u = 10, 99\n    inquire(unit=u, opened=op)\n    if (.not. op) return\n  end do\n  u = -1\nend function get_unit_number",
        "summary": "Finds and returns the first available unit number between 10 and 99."
    },
    {
        "id": 239,
        "code": "program read_non_advancing\n  implicit none\n  integer :: u\n  character(len=5) :: part\n  open(newunit=u, file='data.txt')\n  read(u, '(A5)', advance='no') part\n  print *, part\n  close(u)\nend program read_non_advancing",
        "summary": "Reads 5 characters without advancing to the next record (line)."
    },
    {
        "id": 240,
        "code": "subroutine print_file_content(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer :: u, ios\n  character(len=200) :: line\n  open(newunit=u, file=fname, status='old', iostat=ios)\n  if (ios == 0) then\n    do\n      read(u, '(A)', iostat=ios) line\n      if (ios /= 0) exit\n      print *, trim(line)\n    end do\n    close(u)\n  end if\nend subroutine print_file_content",
        "summary": "Opens a file and prints all its lines to the standard output."
    },
    {
        "id": 241,
        "code": "program check_access_mode\n  implicit none\n  character(len=20) :: acc\n  inquire(file='data.txt', access=acc)\n  print *, 'Access mode:', trim(acc)\nend program check_access_mode",
        "summary": "Inquires and prints the access mode (e.g., SEQUENTIAL, DIRECT) of a file."
    },
    {
        "id": 242,
        "code": "subroutine write_blank_lines(u, n)\n  implicit none\n  integer, intent(in) :: u, n\n  integer :: i\n  do i = 1, n\n    write(u, *)\n  end do\nend subroutine write_blank_lines",
        "summary": "Writes N blank lines to the specified unit."
    },
    {
        "id": 243,
        "code": "program read_into_allocatable\n  implicit none\n  integer :: u, n\n  integer, allocatable :: arr(:)\n  open(newunit=u, file='array.txt')\n  read(u, *) n\n  allocate(arr(n))\n  read(u, *) arr\n  close(u)\nend program read_into_allocatable",
        "summary": "Reads the size of an array, allocates it, and reads the elements from a file."
    },
    {
        "id": 244,
        "code": "subroutine delete_if_exists(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  logical :: exists\n  integer :: u\n  inquire(file=fname, exist=exists)\n  if (exists) then\n    open(newunit=u, file=fname)\n    close(u, status='delete')\n  end if\nend subroutine delete_if_exists",
        "summary": "Checks if a file exists and deletes it if it does."
    },
    {
        "id": 245,
        "code": "program write_utf8_hint\n  implicit none\n  integer :: u\n  ! Fortran 2003+ stream access is often used for binary/UTF-8 exactness\n  open(newunit=u, file='utf8.txt', access='stream')\n  write(u) 'UTF-8 Byte Stream'\n  close(u)\nend program write_utf8_hint",
        "summary": "Writes a string as a byte stream, useful for handling specific encodings like UTF-8."
    },
    {
        "id": 246,
        "code": "subroutine read_skip_lines(u, n)\n  implicit none\n  integer, intent(in) :: u, n\n  integer :: i\n  do i = 1, n\n    read(u, *)\n  end do\nend subroutine read_skip_lines",
        "summary": "Reads and discards N lines from the current position of the file unit."
    },
    {
        "id": 247,
        "code": "program inquire_formatted\n  implicit none\n  character(len=20) :: fmt\n  inquire(file='data.txt', formatted=fmt)\n  print *, 'Formatted I/O allowed:', fmt\nend program inquire_formatted",
        "summary": "Checks if 'data.txt' can be opened for formatted I/O."
    },
    {
        "id": 248,
        "code": "subroutine safe_close(u)\n  implicit none\n  integer, intent(in) :: u\n  logical :: op\n  inquire(unit=u, opened=op)\n  if (op) close(u)\nend subroutine safe_close",
        "summary": "Checks if a unit is open before attempting to close it to avoid errors."
    },
    {
        "id": 249,
        "code": "program write_tab_delimited\n  implicit none\n  integer :: u\n  open(newunit=u, file='data.tsv')\n  write(u, '(A, A1, A)') 'Col1', char(9), 'Col2'\n  close(u)\nend program write_tab_delimited",
        "summary": "Writes a header row with tab delimiters (ASCII 9) to a file."
    },
    {
        "id": 250,
        "code": "subroutine read_until_keyword(u, key)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: key\n  character(len=100) :: line\n  do\n    read(u, '(A)', end=10) line\n    if (index(line, key) > 0) return\n  end do\n10 print *, 'Keyword not found'\nend subroutine read_until_keyword",
        "summary": "Reads lines from a unit until a line containing the specified keyword is found."
    },
    {
        "id": 251,
        "code": "program count_bytes_in_file\n  implicit none\n  integer :: u, count, ios\n  character :: c\n  open(newunit=u, file='data.bin', access='stream', status='old')\n  count = 0\n  do\n    read(u, iostat=ios) c\n    if (ios /= 0) exit\n    count = count + 1\n  end do\n  print *, 'Bytes:', count\n  close(u)\nend program count_bytes_in_file",
        "summary": "Counts the total number of bytes in a file using stream access."
    },
    {
        "id": 252,
        "code": "subroutine write_list_integers(fname, list)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, dimension(:), intent(in) :: list\n  integer :: u, i\n  open(newunit=u, file=fname, status='replace')\n  do i = 1, size(list)\n    write(u, *) list(i)\n  end do\n  close(u)\nend subroutine write_list_integers",
        "summary": "Writes an array of integers to a file, one integer per line."
    },
    {
        "id": 253,
        "code": "program check_unformatted_inquire\n  implicit none\n  character(len=20) :: unf\n  inquire(file='data.bin', unformatted=unf)\n  print *, 'Unformatted allowed:', unf\nend program check_unformatted_inquire",
        "summary": "Inquires if unformatted I/O is allowed for 'data.bin'."
    },
    {
        "id": 254,
        "code": "subroutine open_read_write(fname, u)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(out) :: u\n  open(newunit=u, file=fname, action='readwrite')\nend subroutine open_read_write",
        "summary": "Opens a file for both reading and writing and returns the unit number."
    },
    {
        "id": 255,
        "code": "program read_double_precision\n  implicit none\n  integer :: u\n  double precision :: val\n  open(newunit=u, file='values.txt')\n  read(u, *) val\n  print *, val\n  close(u)\nend program read_double_precision",
        "summary": "Reads a double precision number from 'values.txt'."
    },
    {
        "id": 256,
        "code": "subroutine rewind_if_open(u)\n  implicit none\n  integer, intent(in) :: u\n  logical :: op\n  inquire(unit=u, opened=op)\n  if (op) rewind(u)\nend subroutine rewind_if_open",
        "summary": "Rewinds a unit only if it is currently open."
    },
    {
        "id": 257,
        "code": "program write_formatted_date\n  implicit none\n  integer :: u\n  integer :: d=31, m=12, y=2023\n  open(newunit=u, file='date.txt')\n  write(u, '(I2.2, \"/\", I2.2, \"/\", I4)') d, m, y\n  close(u)\nend program write_formatted_date",
        "summary": "Writes a date in DD/MM/YYYY format with leading zeros for day and month."
    },
    {
        "id": 258,
        "code": "subroutine file_copy_lines(src, dst)\n  implicit none\n  character(len=*), intent(in) :: src, dst\n  integer :: u1, u2, ios\n  character(len=256) :: line\n  open(newunit=u1, file=src, status='old')\n  open(newunit=u2, file=dst, status='replace')\n  do\n    read(u1, '(A)', iostat=ios) line\n    if (ios /= 0) exit\n    write(u2, '(A)') trim(line)\n  end do\n  close(u1)\n  close(u2)\nend subroutine file_copy_lines",
        "summary": "Copies all lines from source file to destination file."
    },
    {
        "id": 259,
        "code": "program check_direct_access\n  implicit none\n  character(len=20) :: acc\n  inquire(file='random.dat', direct=acc)\n  print *, 'Direct access allowed:', acc\nend program check_direct_access",
        "summary": "Checks if direct access is allowed for 'random.dat'."
    },
    {
        "id": 260,
        "code": "subroutine write_to_stderr(msg)\n  implicit none\n  character(len=*), intent(in) :: msg\n  write(0, *) trim(msg)\nend subroutine write_to_stderr",
        "summary": "Writes a message to the standard error unit (unit 0)."
    },
    {
        "id": 261,
        "code": "program read_complex_number\n  implicit none\n  integer :: u\n  complex :: c\n  open(newunit=u, file='complex.dat')\n  read(u, *) c\n  print *, c\n  close(u)\nend program read_complex_number",
        "summary": "Reads a complex number from a file."
    },
    {
        "id": 262,
        "code": "subroutine set_pad_no(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, pad='no')\nend subroutine set_pad_no",
        "summary": "Sets the padding mode to 'no' for the specified open unit."
    },
    {
        "id": 263,
        "code": "program check_read_action\n  implicit none\n  character(len=20) :: act\n  inquire(file='data.txt', action=act)\n  print *, 'Allowed action:', trim(act)\nend program check_read_action",
        "summary": "Inquires the allowed action (read, write, or readwrite) for a file."
    },
    {
        "id": 264,
        "code": "subroutine write_matrix_formatted(u, mat, n)\n  implicit none\n  integer, intent(in) :: u, n\n  real, dimension(n,n), intent(in) :: mat\n  integer :: i, j\n  do i = 1, n\n    write(u, '(100F8.2)') (mat(i,j), j=1,n)\n  end do\nend subroutine write_matrix_formatted",
        "summary": "Writes a square matrix with specific formatting (F8.2) to a unit."
    },
    {
        "id": 265,
        "code": "program read_boolean\n  implicit none\n  integer :: u\n  logical :: flag\n  open(newunit=u, file='config.dat')\n  read(u, *) flag\n  print *, flag\n  close(u)\nend program read_boolean",
        "summary": "Reads a logical (boolean) value from a file."
    },
    {
        "id": 266,
        "code": "subroutine advance_to_line(u, n)\n  implicit none\n  integer, intent(in) :: u, n\n  integer :: i\n  rewind(u)\n  do i = 1, n-1\n    read(u, *)\n  end do\nend subroutine advance_to_line",
        "summary": "Rewinds the file and skips to the Nth line."
    },
    {
        "id": 267,
        "code": "program check_sequential_access\n  implicit none\n  character(len=20) :: seq\n  inquire(file='data.txt', sequential=seq)\n  print *, 'Sequential access:', seq\nend program check_sequential_access",
        "summary": "Checks if sequential access is supported for 'data.txt'."
    },
    {
        "id": 268,
        "code": "subroutine write_csv_header(u, col1, col2)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: col1, col2\n  write(u, '(A, \",\", A)') trim(col1), trim(col2)\nend subroutine write_csv_header",
        "summary": "Writes a two-column CSV header to the specified unit."
    },
    {
        "id": 269,
        "code": "program read_fixed_string\n  implicit none\n  integer :: u\n  character(len=10) :: id\n  open(newunit=u, file='ids.txt')\n  read(u, '(A10)') id\n  print *, id\n  close(u)\nend program read_fixed_string",
        "summary": "Reads exactly 10 characters into a string variable."
    },
    {
        "id": 270,
        "code": "subroutine temp_file_process\n  implicit none\n  integer :: u\n  open(newunit=u, status='scratch')\n  write(u, *) 'Temporary Data'\n  rewind(u)\n  ! Process data\n  close(u)\nend subroutine temp_file_process",
        "summary": "Creates a temporary scratch file, writes to it, uses it, and lets it auto-delete on close."
    },
    {
        "id": 271,
        "code": "program check_write_permission\n  implicit none\n  character(len=20) :: wr\n  inquire(file='log.txt', write=wr)\n  if (trim(wr) == 'NO') print *, 'Read-only file'\nend program check_write_permission",
        "summary": "Checks if write permission is denied for 'log.txt'."
    },
    {
        "id": 272,
        "code": "subroutine append_newline(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, *)\nend subroutine append_newline",
        "summary": "Writes an empty record (newline) to the file unit."
    },
    {
        "id": 273,
        "code": "program read_stream_chunk\n  implicit none\n  integer :: u\n  character(len=10) :: chunk\n  open(newunit=u, file='data.bin', access='stream')\n  read(u) chunk\n  print *, chunk\n  close(u)\nend program read_stream_chunk",
        "summary": "Reads a 10-byte chunk from a stream file."
    },
    {
        "id": 274,
        "code": "subroutine open_append_only(fname, u)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(out) :: u\n  open(newunit=u, file=fname, status='old', position='append', action='write')\nend subroutine open_append_only",
        "summary": "Opens an existing file for writing at the end (append) only."
    },
    {
        "id": 275,
        "code": "program check_exist_and_size\n  implicit none\n  logical :: ex\n  integer :: sz\n  inquire(file='data.dat', exist=ex, size=sz)\n  if (ex) print *, 'Size:', sz\nend program check_exist_and_size",
        "summary": "Checks if a file exists and prints its size if it does."
    },
    {
        "id": 276,
        "code": "subroutine write_centered(u, text, width)\n  implicit none\n  integer, intent(in) :: u, width\n  character(len=*), intent(in) :: text\n  integer :: pad\n  pad = (width - len_trim(text)) / 2\n  write(u, '(A)') repeat(' ', pad) // trim(text)\nend subroutine write_centered",
        "summary": "Writes text centered within a given width to the file unit."
    },
    {
        "id": 277,
        "code": "program read_allocatable_string\n  implicit none\n  integer :: u\n  character(len=:), allocatable :: line\n  character(len=1000) :: buf\n  open(newunit=u, file='longline.txt')\n  read(u, '(A)') buf\n  line = trim(buf)\n  print *, line\n  close(u)\nend program read_allocatable_string",
        "summary": "Reads a line into a large buffer and assigns it to an allocatable string."
    },
    {
        "id": 278,
        "code": "subroutine rewind_unit(u)\n  implicit none\n  integer, intent(in) :: u\n  rewind(u)\nend subroutine rewind_unit",
        "summary": "Resets the file position to the beginning."
    },
    {
        "id": 279,
        "code": "program check_encoding\n  implicit none\n  character(len=20) :: enc\n  inquire(unit=10, encoding=enc)\n  print *, 'Encoding:', enc\nend program check_encoding",
        "summary": "Inquires the encoding (e.g., UTF-8, DEFAULT) of an open unit."
    },
    {
        "id": 280,
        "code": "subroutine write_scientific(u, val)\n  implicit none\n  integer, intent(in) :: u\n  real, intent(in) :: val\n  write(u, '(ES12.5)') val\nend subroutine write_scientific",
        "summary": "Writes a real number in scientific notation (ES format) to a unit."
    },
    {
        "id": 281,
        "code": "program read_partial_line\n  implicit none\n  integer :: u\n  character(len=10) :: part\n  open(newunit=u, file='data.txt')\n  read(u, '(A10)', advance='no') part\n  print *, part\n  close(u)\nend program read_partial_line",
        "summary": "Reads the first 10 characters of a line without advancing to the next line."
    },
    {
        "id": 282,
        "code": "subroutine set_sign_plus(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, sign='PLUS')\nend subroutine set_sign_plus",
        "summary": "Forces the output of a plus sign for positive numbers on the given unit."
    },
    {
        "id": 283,
        "code": "program check_named_file\n  implicit none\n  logical :: nmd\n  inquire(unit=10, named=nmd)\n  if (nmd) print *, 'Unit 10 is named'\nend program check_named_file",
        "summary": "Checks if unit 10 is connected to a named file (as opposed to scratch)."
    },
    {
        "id": 284,
        "code": "subroutine write_int_list(u, list)\n  implicit none\n  integer, intent(in) :: u\n  integer, dimension(:), intent(in) :: list\n  write(u, *) list\nend subroutine write_int_list",
        "summary": "Writes an entire integer array using list-directed output."
    },
    {
        "id": 285,
        "code": "program read_error_label\n  implicit none\n  integer :: u\n  open(newunit=u, file='missing.txt', err=100)\n  ! ... read ops ...\n  stop\n100 print *, 'File open error'\nend program read_error_label",
        "summary": "Uses the 'err=' label to jump to error handling code if file open fails."
    },
    {
        "id": 286,
        "code": "subroutine close_delete_on_error(u, err_flag)\n  implicit none\n  integer, intent(in) :: u\n  logical, intent(in) :: err_flag\n  if (err_flag) then\n    close(u, status='delete')\n  else\n    close(u, status='keep')\n  end if\nend subroutine close_delete_on_error",
        "summary": "Deletes the file on close if an error flag is true, otherwise keeps it."
    },
    {
        "id": 287,
        "code": "program check_pad_mode\n  implicit none\n  character(len=20) :: pd\n  inquire(unit=10, pad=pd)\n  print *, 'Padding:', pd\nend program check_pad_mode",
        "summary": "Inquires the padding mode (YES/NO) for unit 10."
    },
    {
        "id": 288,
        "code": "subroutine write_prompt_no_newline(msg)\n  implicit none\n  character(len=*), intent(in) :: msg\n  write(*, '(A)', advance='no') msg\nend subroutine write_prompt_no_newline",
        "summary": "Writes a prompt to stdout without a trailing newline."
    },
    {
        "id": 289,
        "code": "program read_lines_into_matrix\n  implicit none\n  integer :: u, i\n  real :: mat(3,3)\n  open(newunit=u, file='mat.txt')\n  do i = 1, 3\n    read(u, *) mat(i, :)\n  end do\n  close(u)\nend program read_lines_into_matrix",
        "summary": "Reads a 3x3 matrix from a file, reading one row per line."
    },
    {
        "id": 290,
        "code": "subroutine set_blank_null(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, blank='NULL')\nend subroutine set_blank_null",
        "summary": "Sets blanks in numeric input fields to be ignored (NULL)."
    },
    {
        "id": 291,
        "code": "program check_delim_mode\n  implicit none\n  character(len=20) :: del\n  inquire(unit=10, delim=del)\n  print *, 'Delimiter:', del\nend program check_delim_mode",
        "summary": "Inquires the delimiter character usage (QUOTE, APOSTROPHE, NONE) for unit 10."
    },
    {
        "id": 292,
        "code": "subroutine write_bool_char(u, b)\n  implicit none\n  integer, intent(in) :: u\n  logical, intent(in) :: b\n  write(u, '(L1)') b\nend subroutine write_bool_char",
        "summary": "Writes a logical value as a single character (T or F)."
    },
    {
        "id": 293,
        "code": "program read_eor_handle\n  implicit none\n  integer :: u, val, ios\n  open(newunit=u, file='data.txt')\n  read(u, '(I5)', advance='no', eor=99, iostat=ios) val\n  stop\n99 print *, 'End of record reached'\nend program read_eor_handle",
        "summary": "Handles the End-Of-Record condition when performing non-advancing read."
    },
    {
        "id": 294,
        "code": "subroutine skip_record(u)\n  implicit none\n  integer, intent(in) :: u\n  read(u, *)\nend subroutine skip_record",
        "summary": "Reads and ignores one record from the specified unit."
    },
    {
        "id": 295,
        "code": "program check_readwrite_access\n  implicit none\n  character(len=20) :: rw\n  inquire(file='data.dat', readwrite=rw)\n  print *, 'ReadWrite allowed:', rw\nend program check_readwrite_access",
        "summary": "Checks if read-write access is allowed for 'data.dat'."
    },
    {
        "id": 296,
        "code": "subroutine write_integer_width(u, val, w)\n  implicit none\n  integer, intent(in) :: u, val, w\n  character(len=20) :: fmt\n  write(fmt, '(\"(I\", I0, \")\")') w\n  write(u, fmt) val\nend subroutine write_integer_width",
        "summary": "Writes an integer with a dynamic field width constructed at runtime."
    },
    {
        "id": 297,
        "code": "program read_list_directed\n  implicit none\n  integer :: u\n  integer :: arr(5)\n  open(newunit=u, file='nums.txt')\n  read(u, *) arr\n  close(u)\nend program read_list_directed",
        "summary": "Reads 5 integers using list-directed input (flexible spacing/lines)."
    },
    {
        "id": 298,
        "code": "subroutine endfile_record(u)\n  implicit none\n  integer, intent(in) :: u\n  endfile(u)\nend subroutine endfile_record",
        "summary": "Writes a special end-of-file record to the unit."
    },
    {
        "id": 299,
        "code": "program check_position\n  implicit none\n  character(len=20) :: pos\n  open(unit=10, file='log.txt', position='append')\n  inquire(unit=10, position=pos)\n  print *, 'Position:', pos\n  close(10)\nend program check_position",
        "summary": "Opens a file in append mode and verifies the position attribute."
    },
    {
        "id": 300,
        "code": "subroutine set_blank_zero(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, blank='ZERO')\nend subroutine set_blank_zero",
        "summary": "Sets blanks in numeric input to be treated as zeros."
    },
    {
        "id": 301,
        "code": "program read_stream_pos\n  implicit none\n  integer :: u, pos\n  character :: c\n  open(newunit=u, file='data.bin', access='stream')\n  read(u) c\n  inquire(unit=u, pos=pos)\n  print *, 'Next byte position:', pos\n  close(u)\nend program read_stream_pos",
        "summary": "Reads a byte from a stream file and inquires the position of the next byte."
    },
    {
        "id": 302,
        "code": "subroutine write_double_array(u, arr)\n  implicit none\n  integer, intent(in) :: u\n  double precision, intent(in) :: arr(:)\n  write(u, *) arr\nend subroutine write_double_array",
        "summary": "Writes a double precision array to a file."
    },
    {
        "id": 303,
        "code": "program check_async_io\n  implicit none\n  character(len=20) :: asy\n  inquire(unit=10, asynchronous=asy)\n  print *, 'Asynchronous I/O:', asy\nend program check_async_io",
        "summary": "Checks if asynchronous I/O is allowed on unit 10."
    },
    {
        "id": 304,
        "code": "subroutine open_replace(fname, u)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(out) :: u\n  open(newunit=u, file=fname, status='replace')\nend subroutine open_replace",
        "summary": "Opens a file for writing, replacing it if it already exists."
    },
    {
        "id": 305,
        "code": "program read_char_loop\n  implicit none\n  integer :: u, ios\n  character :: c\n  open(newunit=u, file='data.txt')\n  do\n    read(u, '(A1)', advance='no', iostat=ios) c\n    if (ios /= 0) exit\n    write(*, *) c\n  end do\n  close(u)\nend program read_char_loop",
        "summary": "Reads a file character by character using non-advancing formatted read."
    },
    {
        "id": 306,
        "code": "subroutine set_decimal_point(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, decimal='POINT')\nend subroutine set_decimal_point",
        "summary": "Sets the decimal separator to a point (default) for the unit."
    },
    {
        "id": 307,
        "code": "program check_recl\n  implicit none\n  integer :: rl\n  inquire(file='direct.dat', recl=rl)\n  print *, 'Record length:', rl\nend program check_recl",
        "summary": "Inquires the record length of 'direct.dat'."
    },
    {
        "id": 308,
        "code": "subroutine write_separator_line(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)') repeat('-', 20)\nend subroutine write_separator_line",
        "summary": "Writes a separator line consisting of 20 dashes."
    },
    {
        "id": 309,
        "code": "program read_integers_eof\n  implicit none\n  integer :: u, i, ios\n  open(newunit=u, file='ints.txt')\n  do\n    read(u, *, iostat=ios) i\n    if (is_iostat_end(ios)) exit\n    print *, i\n  end do\n  close(u)\nend program read_integers_eof",
        "summary": "Reads integers until EOF is detected using `is_iostat_end`."
    },
    {
        "id": 310,
        "code": "subroutine flush_buffer(u)\n  implicit none\n  integer, intent(in) :: u\n  flush(u)\nend subroutine flush_buffer",
        "summary": "Flushes the I/O buffer to disk."
    },
    {
        "id": 311,
        "code": "program check_stream_allowed\n  implicit none\n  character(len=20) :: acc\n  inquire(file='data.bin', access=acc)\n  if (trim(acc) == 'STREAM') print *, 'Stream supported'\nend program check_stream_allowed",
        "summary": "Checks if stream access is supported for 'data.bin'."
    },
    {
        "id": 312,
        "code": "subroutine write_quoted_string(u, str)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: str\n  write(u, '(\"' // \"'\" // '\", A, \"' // \"'\" // '\")') trim(str)\nend subroutine write_quoted_string",
        "summary": "Writes a string enclosed in single quotes."
    },
    {
        "id": 313,
        "code": "program read_namelist_group\n  implicit none\n  integer :: x, y\n  namelist /grp/ x, y\n  integer :: u\n  open(newunit=u, file='data.nml')\n  read(u, nml=grp)\n  close(u)\nend program read_namelist_group",
        "summary": "Reads the namelist group 'grp' from 'data.nml'."
    },
    {
        "id": 314,
        "code": "subroutine close_print(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u)\n  print *, 'Closed unit', u\nend subroutine close_print",
        "summary": "Closes a unit and prints a confirmation."
    },
    {
        "id": 315,
        "code": "program check_write_action\n  implicit none\n  character(len=20) :: act\n  inquire(file='log.txt', action=act)\n  if (act == 'WRITE') print *, 'Write only'\nend program check_write_action",
        "summary": "Checks if the file is opened for write-only access."
    },
    {
        "id": 316,
        "code": "subroutine set_sign_suppress(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, sign='SUPPRESS')\nend subroutine set_sign_suppress",
        "summary": "Suppresses optional plus signs in numeric output for the unit."
    },
    {
        "id": 317,
        "code": "program read_buffer_stream\n  implicit none\n  integer :: u\n  character(len=512) :: buf\n  open(newunit=u, file='data.bin', access='stream')\n  read(u) buf\n  print *, 'Read 512 bytes'\n  close(u)\nend program read_buffer_stream",
        "summary": "Reads 512 bytes into a buffer from a stream file."
    },
    {
        "id": 318,
        "code": "subroutine write_comma_no_nl(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)', advance='no') ','\nend subroutine write_comma_no_nl",
        "summary": "Writes a comma without a trailing newline."
    },
    {
        "id": 319,
        "code": "program check_file_name\n  implicit none\n  character(len=100) :: name\n  inquire(unit=10, name=name)\n  print *, 'Filename:', trim(name)\nend program check_file_name",
        "summary": "Retrieves the filename connected to unit 10."
    },
    {
        "id": 320,
        "code": "subroutine rewind_all_units(units)\n  implicit none\n  integer, dimension(:), intent(in) :: units\n  integer :: i\n  do i = 1, size(units)\n    rewind(units(i))\n  end do\nend subroutine rewind_all_units",
        "summary": "Rewinds all units specified in the input array."
    },
    {
        "id": 321,
        "code": "program read_int_matrix\n  implicit none\n  integer :: u, i\n  integer :: mat(5,5)\n  open(newunit=u, file='matrix.txt')\n  read(u, *) mat\n  close(u)\nend program read_int_matrix",
        "summary": "Reads a 5x5 integer matrix from a file (column-major order by default)."
    },
    {
        "id": 322,
        "code": "subroutine set_round_up(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, round='UP')\nend subroutine set_round_up",
        "summary": "Sets the rounding mode to UP for the specified unit."
    },
    {
        "id": 323,
        "code": "program check_formatted_write\n  implicit none\n  character(len=20) :: fmt\n  inquire(unit=10, formatted=fmt)\n  if (fmt == 'YES') print *, 'Formatted OK'\nend program check_formatted_write",
        "summary": "Checks if formatted I/O is valid for unit 10."
    },
    {
        "id": 324,
        "code": "subroutine write_tab(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)', advance='no') char(9)\nend subroutine write_tab",
        "summary": "Writes a tab character without a newline."
    },
    {
        "id": 325,
        "code": "program read_unknown_count\n  implicit none\n  integer :: u, n, temp, ios\n  open(newunit=u, file='data.txt')\n  n = 0\n  do\n    read(u, *, iostat=ios) temp\n    if (ios /= 0) exit\n    n = n + 1\n  end do\n  print *, 'Count:', n\n  close(u)\nend program read_unknown_count",
        "summary": "Counts the number of integers in a file."
    },
    {
        "id": 326,
        "code": "subroutine close_scratch(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u) ! Deletes scratch file\nend subroutine close_scratch",
        "summary": "Closes a scratch unit, implicitly deleting the temporary file."
    },
    {
        "id": 327,
        "code": "program check_read_only_access\n  implicit none\n  character(len=20) :: act\n  inquire(file='data.txt', action=act)\n  if (act == 'READ') print *, 'Read Only'\nend program check_read_only_access",
        "summary": "Verifies if 'data.txt' is accessible only for reading."
    },
    {
        "id": 328,
        "code": "subroutine write_space(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(1X)', advance='no')\nend subroutine write_space",
        "summary": "Writes a single space character without a newline."
    },
    {
        "id": 329,
        "code": "program read_skip_chars\n  implicit none\n  integer :: u\n  character(len=5) :: val\n  open(newunit=u, file='data.txt')\n  read(u, '(5X, A5)') val\n  print *, val\n  close(u)\nend program read_skip_chars",
        "summary": "Skips 5 characters and reads the next 5 characters."
    },
    {
        "id": 330,
        "code": "subroutine set_round_down(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, round='DOWN')\nend subroutine set_round_down",
        "summary": "Sets the rounding mode to DOWN for the unit."
    },
    {
        "id": 331,
        "code": "program check_opened_status\n  implicit none\n  logical :: op\n  inquire(file='test.txt', opened=op)\n  print *, 'Opened:', op\nend program check_opened_status",
        "summary": "Checks if 'test.txt' is currently open."
    },
    {
        "id": 332,
        "code": "subroutine write_int_formatted(u, val)\n  implicit none\n  integer, intent(in) :: u, val\n  write(u, '(I10)') val\nend subroutine write_int_formatted",
        "summary": "Writes an integer with a fixed width of 10."
    },
    {
        "id": 333,
        "code": "program read_until_error\n  implicit none\n  integer :: u, val, ios\n  open(newunit=u, file='data.txt')\n  do\n    read(u, *, iostat=ios) val\n    if (ios > 0) print *, 'Error reading'\n    if (ios /= 0) exit\n  end do\n  close(u)\nend program read_until_error",
        "summary": "Reads until an error or EOF occurs, printing a message on error."
    },
    {
        "id": 334,
        "code": "subroutine open_new_file(fname, u)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(out) :: u\n  open(newunit=u, file=fname, status='new')\nend subroutine open_new_file",
        "summary": "Opens a new file, failing if it already exists."
    },
    {
        "id": 335,
        "code": "program check_exists\n  implicit none\n  logical :: ex\n  inquire(file='data.txt', exist=ex)\n  if (.not. ex) print *, 'Missing'\nend program check_exists",
        "summary": "Prints 'Missing' if 'data.txt' does not exist."
    },
    {
        "id": 336,
        "code": "subroutine write_real_precision(u, val)\n  implicit none\n  integer, intent(in) :: u\n  real, intent(in) :: val\n  write(u, '(F20.10)') val\nend subroutine write_real_precision",
        "summary": "Writes a real number with high precision (10 decimal places)."
    },
    {
        "id": 337,
        "code": "program read_allocatable_vector\n  implicit none\n  integer :: u, n\n  real, allocatable :: vec(:)\n  open(newunit=u, file='vec.txt')\n  read(u, *) n\n  allocate(vec(n))\n  read(u, *) vec\n  close(u)\nend program read_allocatable_vector",
        "summary": "Reads vector size N and then N real elements."
    },
    {
        "id": 338,
        "code": "subroutine check_io_status(ios)\n  implicit none\n  integer, intent(in) :: ios\n  if (ios /= 0) print *, 'I/O Status:', ios\nend subroutine check_io_status",
        "summary": "Prints the I/O status code if it indicates a non-zero condition."
    },
    {
        "id": 339,
        "code": "program check_unformatted_write\n  implicit none\n  character(len=20) :: unf\n  inquire(file='bin.dat', unformatted=unf)\n  if (unf == 'YES') print *, 'Unformatted OK'\nend program check_unformatted_write",
        "summary": "Checks if unformatted I/O is allowed for 'bin.dat'."
    },
    {
        "id": 340,
        "code": "subroutine write_newline(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, *)\nend subroutine write_newline",
        "summary": "Writes a newline to the unit."
    },
    {
        "id": 341,
        "code": "program read_string_line\n  implicit none\n  integer :: u\n  character(len=80) :: line\n  open(newunit=u, file='text.txt')\n  read(u, '(A)') line\n  close(u)\nend program read_string_line",
        "summary": "Reads a single line of text (up to 80 chars)."
    },
    {
        "id": 342,
        "code": "subroutine set_round_nearest(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, round='NEAREST')\nend subroutine set_round_nearest",
        "summary": "Sets rounding to nearest integer."
    },
    {
        "id": 343,
        "code": "program check_read_permission\n  implicit none\n  character(len=20) :: rd\n  inquire(file='data.txt', read=rd)\n  if (rd == 'YES') print *, 'Read OK'\nend program check_read_permission",
        "summary": "Verifies read permissions for 'data.txt'."
    },
    {
        "id": 344,
        "code": "subroutine write_header(u, txt)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: txt\n  write(u, '(\"# \", A)') trim(txt)\nend subroutine write_header",
        "summary": "Writes a header line prefixed with '# '."
    },
    {
        "id": 345,
        "code": "program read_stream_byte\n  implicit none\n  integer :: u\n  integer(1) :: b\n  open(newunit=u, file='data.bin', access='stream')\n  read(u) b\n  print *, b\n  close(u)\nend program read_stream_byte",
        "summary": "Reads a single byte as a 1-byte integer from a stream file."
    },
    {
        "id": 346,
        "code": "subroutine close_keep_file(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u, status='keep')\nend subroutine close_keep_file",
        "summary": "Closes a unit while preserving the file."
    },
    {
        "id": 347,
        "code": "program check_direct_write\n  implicit none\n  character(len=20) :: dir\n  inquire(file='data.dat', direct=dir)\n  if (dir == 'YES') print *, 'Direct OK'\nend program check_direct_write",
        "summary": "Checks if direct access is allowed."
    },
    {
        "id": 348,
        "code": "subroutine write_quoted(u, s)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: s\n  write(u, '(\"' // \"'\" // '\", A, \"' // \"'\" // '\")') trim(s)\nend subroutine write_quoted",
        "summary": "Writes a string surrounded by single quotes."
    },
    {
        "id": 349,
        "code": "program read_skip_record\n  implicit none\n  integer :: u, val\n  open(newunit=u, file='data.txt')\n  read(u, *)\n  read(u, *) val\n  print *, val\n  close(u)\nend program read_skip_record",
        "summary": "Skips the first record and reads a value from the second."
    },
    {
        "id": 350,
        "code": "subroutine set_round_zero(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, round='ZERO')\nend subroutine set_round_zero",
        "summary": "Sets rounding toward zero (truncation) for the unit."
    },
    {
        "id": 351,
        "code": "program check_seq_access\n  implicit none\n  character(len=20) :: seq\n  inquire(file='data.txt', sequential=seq)\n  if (seq == 'YES') print *, 'Sequential OK'\nend program check_seq_access",
        "summary": "Verifies sequential access support."
    },
    {
        "id": 352,
        "code": "subroutine write_int_array(u, arr)\n  implicit none\n  integer, intent(in) :: u\n  integer, dimension(:), intent(in) :: arr\n  write(u, *) arr\nend subroutine write_int_array",
        "summary": "Writes an integer array using default formatting."
    },
    {
        "id": 353,
        "code": "program read_internal_format\n  implicit none\n  character(len=20) :: s = '123'\n  integer :: i\n  read(s, '(I3)') i\n  print *, i\nend program read_internal_format",
        "summary": "Reads an integer from a string using a fixed I3 format."
    },
    {
        "id": 354,
        "code": "subroutine flush_io(u)\n  implicit none\n  integer, intent(in) :: u\n  flush(u)\nend subroutine flush_io",
        "summary": "Flushes the unit buffer."
    },
    {
        "id": 355,
        "code": "program check_write_mode\n  implicit none\n  character(len=20) :: wr\n  inquire(file='data.txt', write=wr)\n  if (wr == 'YES') print *, 'Write OK'\nend program check_write_mode",
        "summary": "Checks if write access is permitted."
    },
    {
        "id": 356,
        "code": "subroutine write_real_fmt(u, val)\n  implicit none\n  integer, intent(in) :: u\n  real, intent(in) :: val\n  write(u, '(F10.4)') val\nend subroutine write_real_fmt",
        "summary": "Writes a real number with 4 decimal places."
    },
    {
        "id": 357,
        "code": "program read_ignore_iostat\n  implicit none\n  integer :: u, val\n  open(newunit=u, file='data.txt')\n  read(u, *, iostat=*) val\n  close(u)\nend program read_ignore_iostat",
        "summary": "Reads a value, ignoring I/O errors (non-standard syntax in some compilers, but logic is to ignore)."
    },
    {
        "id": 358,
        "code": "subroutine close_delete(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u, status='delete')\nend subroutine close_delete",
        "summary": "Closes a unit and deletes the file."
    },
    {
        "id": 359,
        "code": "program check_exist_file\n  implicit none\n  logical :: ex\n  inquire(file='test.dat', exist=ex)\n  print *, ex\nend program check_exist_file",
        "summary": "Prints .TRUE. if 'test.dat' exists."
    },
    {
        "id": 360,
        "code": "subroutine write_str_no_adv(u, s)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: s\n  write(u, '(A)', advance='no') trim(s)\nend subroutine write_str_no_adv",
        "summary": "Writes a string without a newline."
    },
    {
        "id": 361,
        "code": "program read_logical_val\n  implicit none\n  integer :: u\n  logical :: b\n  open(newunit=u, file='bool.txt')\n  read(u, *) b\n  close(u)\nend program read_logical_val",
        "summary": "Reads a logical value from a file."
    },
    {
        "id": 362,
        "code": "subroutine set_recl(u, n)\n  implicit none\n  integer, intent(in) :: u, n\n  ! RECL is set at OPEN\nend subroutine set_recl",
        "summary": "Placeholder: RECL must be set when opening the file."
    },
    {
        "id": 363,
        "code": "program check_namelist_read\n  implicit none\n  integer :: a\n  namelist /nml/ a\n  integer :: u\n  open(newunit=u, file='input.nml')\n  read(u, nml=nml)\n  print *, a\n  close(u)\nend program check_namelist_read",
        "summary": "Reads a simple namelist."
    },
    {
        "id": 364,
        "code": "subroutine write_header_line(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)') 'DATA START'\nend subroutine write_header_line",
        "summary": "Writes a start marker line."
    },
    {
        "id": 365,
        "code": "program read_allocatable_lines\n  implicit none\n  integer :: u, n\n  character(len=50), allocatable :: lines(:)\n  open(newunit=u, file='text.txt')\n  read(u, *) n\n  allocate(lines(n))\n  read(u, '(A)') lines\n  close(u)\nend program read_allocatable_lines",
        "summary": "Reads N lines into an allocatable array of strings."
    },
    {
        "id": 366,
        "code": "subroutine rewind_file(u)\n  implicit none\n  integer, intent(in) :: u\n  rewind(u)\nend subroutine rewind_file",
        "summary": "Rewinds the file."
    },
    {
        "id": 367,
        "code": "program check_stream_read\n  implicit none\n  integer :: u\n  character :: c\n  open(newunit=u, file='data.bin', access='stream')\n  read(u) c\n  close(u)\nend program check_stream_read",
        "summary": "Reads a character from a stream file."
    },
    {
        "id": 368,
        "code": "subroutine write_comma_sep(u, a, b)\n  implicit none\n  integer, intent(in) :: u, a, b\n  write(u, '(I0, \",\", I0)') a, b\nend subroutine write_comma_sep",
        "summary": "Writes two integers separated by a comma."
    },
    {
        "id": 369,
        "code": "program read_formatted_fixed\n  implicit none\n  integer :: u\n  real :: x\n  open(newunit=u, file='data.txt')\n  read(u, '(F5.2)') x\n  close(u)\nend program read_formatted_fixed",
        "summary": "Reads a real number with fixed F5.2 format."
    },
    {
        "id": 370,
        "code": "subroutine backspace_unit(u)\n  implicit none\n  integer, intent(in) :: u\n  backspace(u)\nend subroutine backspace_unit",
        "summary": "Backspaces the unit."
    },
    {
        "id": 371,
        "code": "program check_pad_yes\n  implicit none\n  character(len=20) :: pd\n  inquire(unit=10, pad=pd)\n  if (pd == 'YES') print *, 'Pad enabled'\nend program check_pad_yes",
        "summary": "Checks if padding is enabled."
    },
    {
        "id": 372,
        "code": "subroutine write_blank(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, *)\nend subroutine write_blank",
        "summary": "Writes a blank line."
    },
    {
        "id": 373,
        "code": "program read_double_val\n  implicit none\n  integer :: u\n  double precision :: d\n  open(newunit=u, file='dbl.txt')\n  read(u, *) d\n  close(u)\nend program read_double_val",
        "summary": "Reads a double precision value."
    },
    {
        "id": 374,
        "code": "subroutine close_unit(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u)\nend subroutine close_unit",
        "summary": "Closes the unit."
    },
    {
        "id": 375,
        "code": "program check_size_file\n  implicit none\n  integer :: sz\n  inquire(file='data.txt', size=sz)\n  print *, sz\nend program check_size_file",
        "summary": "Prints the file size."
    },
    {
        "id": 376,
        "code": "subroutine write_int(u, i)\n  implicit none\n  integer, intent(in) :: u, i\n  write(u, *) i\nend subroutine write_int",
        "summary": "Writes an integer."
    },
    {
        "id": 377,
        "code": "program read_err_handle\n  implicit none\n  integer :: u, ios\n  open(newunit=u, file='bad.txt', iostat=ios)\n  if (ios /= 0) print *, 'Error'\nend program read_err_handle",
        "summary": "Handles file open error."
    },
    {
        "id": 378,
        "code": "subroutine open_scratch(u)\n  implicit none\n  integer, intent(out) :: u\n  open(newunit=u, status='scratch')\nend subroutine open_scratch",
        "summary": "Opens a scratch file."
    },
    {
        "id": 379,
        "code": "program check_delim_none\n  implicit none\n  character(len=20) :: del\n  inquire(unit=10, delim=del)\n  if (del == 'NONE') print *, 'No delim'\nend program check_delim_none",
        "summary": "Checks for no delimiter."
    },
    {
        "id": 380,
        "code": "subroutine write_title(u, t)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: t\n  write(u, '(A)') trim(t)\nend subroutine write_title",
        "summary": "Writes a title line."
    },
    {
        "id": 381,
        "code": "program read_complex_val\n  implicit none\n  integer :: u\n  complex :: c\n  open(newunit=u, file='cpx.txt')\n  read(u, *) c\n  close(u)\nend program read_complex_val",
        "summary": "Reads a complex value."
    },
    {
        "id": 382,
        "code": "subroutine set_blank_null(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, blank='NULL')\nend subroutine set_blank_null",
        "summary": "Sets blank to null."
    },
    {
        "id": 383,
        "code": "program check_encoding_default\n  implicit none\n  character(len=20) :: enc\n  inquire(unit=10, encoding=enc)\n  if (enc == 'DEFAULT') print *, 'Default enc'\nend program check_encoding_default",
        "summary": "Checks for default encoding."
    },
    {
        "id": 384,
        "code": "subroutine write_label(u, l)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: l\n  write(u, '(A, \": \")', advance='no') trim(l)\nend subroutine write_label",
        "summary": "Writes a label with colon."
    },
    {
        "id": 385,
        "code": "program read_part_rec\n  implicit none\n  integer :: u, i\n  open(newunit=u, file='data.txt')\n  read(u, '(I5)', advance='no') i\n  close(u)\nend program read_part_rec",
        "summary": "Reads partial record."
    },
    {
        "id": 386,
        "code": "subroutine endfile_u(u)\n  implicit none\n  integer, intent(in) :: u\n  endfile(u)\nend subroutine endfile_u",
        "summary": "Writes EOF."
    },
    {
        "id": 387,
        "code": "program check_formatted_seq\n  implicit none\n  character(len=20) :: fmt\n  inquire(file='data.txt', formatted=fmt)\n  print *, fmt\nend program check_formatted_seq",
        "summary": "Checks formatted access."
    },
    {
        "id": 388,
        "code": "subroutine write_log(u, m)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: m\n  write(u, *) 'LOG:', trim(m)\nend subroutine write_log",
        "summary": "Writes a log message."
    },
    {
        "id": 389,
        "code": "program read_open_status\n  implicit none\n  logical :: op\n  inquire(file='f.txt', opened=op)\n  print *, op\nend program read_open_status",
        "summary": "Checks opened status."
    },
    {
        "id": 390,
        "code": "subroutine write_dash(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)') '-'\nend subroutine write_dash",
        "summary": "Writes a dash."
    },
    {
        "id": 391,
        "code": "program check_unformatted_seq\n  implicit none\n  character(len=20) :: unf\n  inquire(file='b.dat', unformatted=unf)\n  print *, unf\nend program check_unformatted_seq",
        "summary": "Checks unformatted access."
    },
    {
        "id": 392,
        "code": "subroutine open_append(u, f)\n  implicit none\n  integer, intent(out) :: u\n  character(len=*), intent(in) :: f\n  open(newunit=u, file=f, position='append')\nend subroutine open_append",
        "summary": "Opens for append."
    },
    {
        "id": 393,
        "code": "program read_next_rec\n  implicit none\n  integer :: u\n  open(newunit=u, file='data.txt')\n  read(u, *)\n  close(u)\nend program read_next_rec",
        "summary": "Reads next record."
    },
    {
        "id": 394,
        "code": "subroutine close_save(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u, status='keep')\nend subroutine close_save",
        "summary": "Closes and saves."
    },
    {
        "id": 395,
        "code": "program check_read_mode\n  implicit none\n  character(len=20) :: acc\n  inquire(file='d.txt', action=acc)\n  print *, acc\nend program check_read_mode",
        "summary": "Checks access mode."
    },
    {
        "id": 396,
        "code": "subroutine write_val(u, v)\n  implicit none\n  integer, intent(in) :: u\n  real, intent(in) :: v\n  write(u, *) v\nend subroutine write_val",
        "summary": "Writes a value."
    },
    {
        "id": 397,
        "code": "program read_scalar\n  implicit none\n  integer :: u, k\n  open(newunit=u, file='k.txt')\n  read(u, *) k\n  close(u)\nend program read_scalar",
        "summary": "Reads a scalar."
    },
    {
        "id": 398,
        "code": "subroutine set_decimal_comma(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, decimal='comma')\nend subroutine set_decimal_comma",
        "summary": "Sets decimal comma."
    },
    {
        "id": 399,
        "code": "program check_exist_path\n  implicit none\n  logical :: ex\n  inquire(file='/tmp/data', exist=ex)\n  print *, ex\nend program check_exist_path",
        "summary": "Checks path existence."
    },
    {
        "id": 400,
        "code": "subroutine write_end(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, *) 'END'\nend subroutine write_end",
        "summary": "Writes END marker."
    },
    {
        "id": 401,
        "code": "program read_matrix_skip_header\n  implicit none\n  integer :: u, i, j\n  real :: matrix(10, 10)\n  open(newunit=u, file='matrix_data.txt', status='old')\n  read(u, *) ! Skip the header line\n  read(u, *) ((matrix(i,j), j=1,10), i=1,10)\n  close(u)\nend program read_matrix_skip_header",
        "summary": "Opens an existing file named 'matrix_data.txt', explicitly skips the first header line, and then reads a 10x10 matrix of real numbers into an array using an implied do-loop structure."
    },
    {
        "id": 402,
        "code": "subroutine check_and_delete(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  logical :: file_exists\n  integer :: u\n  inquire(file=fname, exist=file_exists)\n  if (file_exists) then\n    open(newunit=u, file=fname, status='old')\n    close(u, status='delete')\n    print *, 'File ', trim(fname), ' has been deleted.'\n  else\n    print *, 'File ', trim(fname), ' does not exist.'\n  end if\nend subroutine check_and_delete",
        "summary": "Checks for the existence of a file with the provided filename; if the file is found, it is opened and immediately closed with the 'delete' status to remove it from the file system, otherwise a message is printed."
    },
    {
        "id": 403,
        "code": "program append_timestamp_log\n  implicit none\n  integer :: u\n  character(len=8) :: date_val\n  character(len=10) :: time_val\n  call date_and_time(date=date_val, time=time_val)\n  open(newunit=u, file='system.log', status='old', position='append', action='write')\n  write(u, '(A, 1X, A, \": System check initiated.\")') date_val, time_val\n  close(u)\nend program append_timestamp_log",
        "summary": "Retrieves the current system date and time, opens an existing log file named 'system.log' positioned at the end of the file, and appends a timestamped log entry indicating a system check initiation."
    },
    {
        "id": 404,
        "code": "subroutine read_until_empty_line(u)\n  implicit none\n  integer, intent(in) :: u\n  character(len=256) :: line\n  integer :: ios\n  do\n    read(u, '(A)', iostat=ios) line\n    if (ios /= 0 .or. len_trim(line) == 0) exit\n    print *, 'Processing: ', trim(line)\n  end do\nend subroutine read_until_empty_line",
        "summary": "Iterates through lines in an open file unit, reading and printing each line's content until either an I/O error occurs (such as End-Of-File) or an empty line is encountered, at which point the loop terminates."
    },
    {
        "id": 405,
        "code": "program binary_stream_copy\n  implicit none\n  integer :: src_u, dst_u, ios\n  character :: byte_buffer\n  open(newunit=src_u, file='source.bin', access='stream', status='old')\n  open(newunit=dst_u, file='backup.bin', access='stream', status='replace')\n  do\n    read(src_u, iostat=ios) byte_buffer\n    if (ios /= 0) exit\n    write(dst_u) byte_buffer\n  end do\n  close(src_u)\n  close(dst_u)\nend program binary_stream_copy",
        "summary": "Performs a byte-by-byte copy of a binary file named 'source.bin' to a new file named 'backup.bin' using Fortran's stream access mode to handle unformatted binary data accurately."
    },
    {
        "id": 406,
        "code": "subroutine write_centered_header(u, title, width)\n  implicit none\n  integer, intent(in) :: u, width\n  character(len=*), intent(in) :: title\n  integer :: padding\n  padding = max(0, (width - len_trim(title)) / 2)\n  write(u, '(A)') repeat('=', width)\n  write(u, '(A)') repeat(' ', padding) // trim(title)\n  write(u, '(A)') repeat('=', width)\nend subroutine write_centered_header",
        "summary": "Writes a decorative header to the specified file unit, consisting of a top border of equals signs, the title text centered within the specified width, and a bottom border of equals signs."
    },
    {
        "id": 407,
        "code": "program inquire_file_properties\n  implicit none\n  character(len=64) :: filename = 'data.txt'\n  logical :: exists, opened\n  integer :: file_size\n  inquire(file=filename, exist=exists, opened=opened, size=file_size)\n  if (exists) then\n    print *, 'File exists. Open status:', opened, ' Size (bytes):', file_size\n  else\n    print *, 'File does not exist.'\n  end if\nend program inquire_file_properties",
        "summary": "Queries the properties of 'data.txt' to determine if it exists, whether it is currently opened by the program, and its size in bytes, printing the results to the standard output."
    },
    {
        "id": 408,
        "code": "subroutine read_fixed_width_records(u, id, val1, val2)\n  implicit none\n  integer, intent(in) :: u\n  integer, intent(out) :: id\n  real, intent(out) :: val1, val2\n  ! Assumes format: ID (5 chars), Val1 (10 chars), Val2 (10 chars)\n  read(u, '(I5, F10.2, F10.2)') id, val1, val2\nend subroutine read_fixed_width_records",
        "summary": "Reads a single record from the specified unit using a fixed-width format, parsing the first 5 characters as an integer ID and the next two 10-character fields as real numbers."
    },
    {
        "id": 409,
        "code": "program create_temp_scratch_file\n  implicit none\n  integer :: temp_u\n  integer :: i, val\n  open(newunit=temp_u, status='scratch', action='readwrite')\n  do i = 1, 10\n    write(temp_u, *) i * 10\n  end do\n  rewind(temp_u)\n  read(temp_u, *) val\n  print *, 'First value in scratch file:', val\n  close(temp_u) ! File is automatically deleted here\nend program create_temp_scratch_file",
        "summary": "Creates a temporary 'scratch' file that exists only for the duration of the connection, writes ten integer values to it, rewinds to the beginning to read the first value, and effectively deletes the file upon closing."
    },
    {
        "id": 410,
        "code": "subroutine count_csv_columns(line, count)\n  implicit none\n  character(len=*), intent(in) :: line\n  integer, intent(out) :: count\n  integer :: i\n  count = 1\n  if (len_trim(line) == 0) then\n    count = 0\n    return\n  end if\n  do i = 1, len_trim(line)\n    if (line(i:i) == ',') count = count + 1\n  end do\nend subroutine count_csv_columns",
        "summary": "Analyzes a string representing a line from a CSV file and counts the number of columns by iterating through the characters and tallying the occurrences of commas, assuming standard CSV formatting."
    },
    {
        "id": 411,
        "code": "program read_namelist_configuration\n  implicit none\n  integer :: max_iter\n  real :: tolerance\n  character(len=20) :: method\n  namelist /solver_params/ max_iter, tolerance, method\n  integer :: u\n  open(newunit=u, file='solver.conf', status='old')\n  read(u, nml=solver_params)\n  print *, 'Method:', trim(method), ' Iterations:', max_iter\n  close(u)\nend program read_namelist_configuration",
        "summary": "Opens a configuration file named 'solver.conf' and uses a Fortran namelist read to load the values for `max_iter`, `tolerance`, and `method` directly into their corresponding variables."
    },
    {
        "id": 412,
        "code": "subroutine handle_open_error(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer :: u, ios\n  open(newunit=u, file=fname, status='old', iostat=ios)\n  if (ios /= 0) then\n    write(0, *) 'Critical Error: Unable to open file ', trim(fname), '. IOSTAT=', ios\n    stop 1\n  end if\n  close(u)\nend subroutine handle_open_error",
        "summary": "Attempts to open a file with the given filename; if the operation fails (indicated by a non-zero IOSTAT), it writes a critical error message to the standard error unit and terminates the program execution."
    },
    {
        "id": 413,
        "code": "program direct_access_update\n  implicit none\n  integer :: u, rec_num\n  real :: new_value = 99.99\n  open(newunit=u, file='data.db', access='direct', recl=4, status='old')\n  rec_num = 5\n  write(u, rec=rec_num) new_value\n  print *, 'Updated record', rec_num, 'with value', new_value\n  close(u)\nend program direct_access_update",
        "summary": "Opens a binary file for direct access with a record length of 4 bytes and updates the data at the 5th record position with a new floating-point value."
    },
    {
        "id": 414,
        "code": "subroutine print_file_content_with_line_numbers(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer :: u, line_num, ios\n  character(len=256) :: buffer\n  open(newunit=u, file=fname, status='old', iostat=ios)\n  if (ios == 0) then\n    line_num = 1\n    do\n      read(u, '(A)', iostat=ios) buffer\n      if (ios /= 0) exit\n      print '(I4, \": \", A)', line_num, trim(buffer)\n      line_num = line_num + 1\n    end do\n    close(u)\n  end if\nend subroutine print_file_content_with_line_numbers",
        "summary": "Reads a text file line by line and prints each line to standard output prefixed with a sequentially incrementing line number and a colon separator."
    },
    {
        "id": 415,
        "code": "program check_permissions_and_read\n  implicit none\n  character(len=20) :: read_perm\n  integer :: u\n  character(len=100) :: first_line\n  inquire(file='secure_data.txt', read=read_perm)\n  if (trim(read_perm) == 'YES') then\n    open(newunit=u, file='secure_data.txt', status='old')\n    read(u, '(A)') first_line\n    print *, 'Data:', trim(first_line)\n    close(u)\n  else\n    print *, 'Permission denied: Cannot read file.'\n  end if\nend program check_permissions_and_read",
        "summary": "First checks if the application has read permissions for 'secure_data.txt' using the inquire statement; if permitted, it opens the file and reads the first line, otherwise it prints a permission denied message."
    },
    {
        "id": 416,
        "code": "subroutine write_double_precision_sci(u, val)\n  implicit none\n  integer, intent(in) :: u\n  double precision, intent(in) :: val\n  write(u, '(ES20.10E3)') val\nend subroutine write_double_precision_sci",
        "summary": "Writes a double precision floating-point value to the specified unit using scientific notation (ES format) with 20 characters width, 10 decimal places, and a 3-digit exponent."
    },
    {
        "id": 417,
        "code": "program detect_end_of_file\n  implicit none\n  integer :: u, val, ios\n  open(newunit=u, file='integers.txt', status='old')\n  do\n    read(u, *, iostat=ios) val\n    if (is_iostat_end(ios)) then\n      print *, 'Reached end of file safely.'\n      exit\n    else if (ios /= 0) then\n      print *, 'An error occurred reading the file.'\n      exit\n    end if\n    print *, 'Read value:', val\n  end do\n  close(u)\nend program detect_end_of_file",
        "summary": "Reads integers from a file in a loop, explicitly distinguishing between a normal End-Of-File condition (using the intrinsic `is_iostat_end`) and other potential I/O errors."
    },
    {
        "id": 418,
        "code": "subroutine skip_n_records(u, n)\n  implicit none\n  integer, intent(in) :: u, n\n  integer :: i\n  do i = 1, n\n    read(u, *) ! Skips one record\n  end do\nend subroutine skip_n_records",
        "summary": "Advances the file position of the specified open unit by reading and discarding `n` records sequentially, effectively skipping them."
    },
    {
        "id": 419,
        "code": "program internal_write_formatting\n  implicit none\n  character(len=50) :: message\n  integer :: error_code = 404\n  character(len=10) :: status = 'Not Found'\n  write(message, '(A, \": \", I3, \" - \", A)') 'Error', error_code, status\n  print *, trim(message)\nend program internal_write_formatting",
        "summary": "Constructs a formatted error string in memory by performing an internal write to the character variable `message`, combining string literals, an integer, and a character variable."
    },
    {
        "id": 420,
        "code": "subroutine get_file_size_in_kb(fname, size_kb)\n  implicit none\n  character(len=*), intent(in) :: fname\n  real, intent(out) :: size_kb\n  integer :: size_bytes\n  inquire(file=fname, size=size_bytes)\n  size_kb = real(size_bytes) / 1024.0\nend subroutine get_file_size_in_kb",
        "summary": "Determines the size of a specified file in bytes using the `inquire` statement and converts that value to kilobytes (KB) as a real number."
    },
    {
        "id": 421,
        "code": "program read_non_advancing_input\n  implicit none\n  integer :: u\n  character(len=3) :: part1, part2\n  open(newunit=u, file='codes.txt', status='old')\n  ! Read first 3 chars, stay on line, read next 3 chars\n  read(u, '(A3)', advance='no') part1\n  read(u, '(A3)', advance='no') part2\n  print *, 'Parts:', part1, '-', part2\n  close(u)\nend program read_non_advancing_input",
        "summary": "Reads two consecutive 3-character segments from the same line of a file using non-advancing I/O (`advance='no'`), allowing multiple read statements to process a single record."
    },
    {
        "id": 422,
        "code": "subroutine write_boolean_as_string(u, flag)\n  implicit none\n  integer, intent(in) :: u\n  logical, intent(in) :: flag\n  if (flag) then\n    write(u, '(A)') 'true'\n  else\n    write(u, '(A)') 'false'\n  end if\nend subroutine write_boolean_as_string",
        "summary": "Accepts a logical flag and writes the string literal 'true' or 'false' to the specified file unit, rather than the standard Fortran 'T' or 'F' output."
    },
    {
        "id": 423,
        "code": "program open_file_replace_existing\n  implicit none\n  integer :: u\n  character(len=20) :: fname = 'results.dat'\n  open(newunit=u, file=fname, status='replace', action='write')\n  write(u, *) 'New Dataset Started'\n  close(u)\n  print *, 'File ', trim(fname), ' was overwritten/created.'\nend program open_file_replace_existing",
        "summary": "Opens a file named 'results.dat' with `status='replace'`, which creates the file if it doesn't exist or deletes and recreates it if it does, ensuring a fresh start for writing data."
    },
    {
        "id": 424,
        "code": "subroutine extract_diagonal(fname, diag, n)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(in) :: n\n  real, dimension(n), intent(out) :: diag\n  integer :: u, i, j\n  real :: val\n  open(newunit=u, file=fname)\n  do i = 1, n\n    read(u, *) (val, j=1,n)\n    ! Inefficient but illustrative: read row, but extracting diagonal logic requires array or buffer\n    ! This snippet assumes strictly reading the i-th element effectively\n    ! Correct logic for stream or direct access is better, but for seq:\n    backspace(u)\n    read(u, *) (val, j=1,i) ! Read up to diagonal\n    diag(i) = val\n    read(u, *) ! consume rest of line\n  end do\n  close(u)\nend subroutine extract_diagonal",
        "summary": "Reads an NxN matrix from a file row by row and extracts only the diagonal elements into a vector, discarding the off-diagonal elements."
    },
    {
        "id": 425,
        "code": "program check_stream_support\n  implicit none\n  character(len=10) :: access_method\n  inquire(file='binary_data.dat', access=access_method)\n  if (trim(access_method) == 'STREAM') then\n    print *, 'Stream access is supported for this file.'\n  else\n    print *, 'Stream access might not be default or supported.'\n  end if\nend program check_stream_support",
        "summary": "Inquires about the access method for 'binary_data.dat' to check if 'STREAM' access is returned, indicating the file system or compiler treats it as suitable for stream I/O."
    },
    {
        "id": 426,
        "code": "subroutine close_and_report(u)\n  implicit none\n  integer, intent(in) :: u\n  character(len=256) :: fname\n  logical :: opened\n  inquire(unit=u, opened=opened, name=fname)\n  if (opened) then\n    close(u)\n    print *, 'Closed file: ', trim(fname)\n  else\n    print *, 'Unit was not open.'\n  end if\nend subroutine close_and_report",
        "summary": "Checks if a specific unit number is currently open; if so, it retrieves the associated filename, closes the unit, and prints a confirmation message including the filename."
    },
    {
        "id": 427,
        "code": "program read_allocatable_array_from_file\n  implicit none\n  integer :: u, n\n  integer, allocatable :: arr(:)\n  open(newunit=u, file='array_config.txt')\n  read(u, *) n\n  allocate(arr(n))\n  read(u, *) arr\n  print *, 'Read ', size(arr), ' elements.'\n  close(u)\nend program read_allocatable_array_from_file",
        "summary": "Reads an integer `n` from the first line of a file, dynamically allocates an integer array of size `n`, and then populates the array by reading the subsequent values from the file."
    },
    {
        "id": 428,
        "code": "subroutine write_indented(u, text, indent_level)\n  implicit none\n  integer, intent(in) :: u, indent_level\n  character(len=*), intent(in) :: text\n  character(len=20) :: fmt\n  write(fmt, '(\"(T\", I0, \", A)\")') indent_level + 1\n  write(u, fmt) trim(text)\nend subroutine write_indented",
        "summary": "Writes a text string to a file indented by a specific number of columns, constructing a dynamic format string to utilize the `T` (tab) edit descriptor."
    },
    {
        "id": 429,
        "code": "program check_formatted_capability\n  implicit none\n  character(len=20) :: fmt_status\n  inquire(file='text_data.txt', formatted=fmt_status)\n  if (trim(fmt_status) == 'YES') then\n    print *, 'File can be opened for formatted I/O.'\n  else\n    print *, 'Formatted I/O not allowed or unknown.'\n  end if\nend program check_formatted_capability",
        "summary": "Inquires whether a specific file ('text_data.txt') supports formatted input/output operations and prints a confirmation message if the status is 'YES'."
    },
    {
        "id": 430,
        "code": "subroutine read_until_keyword_found(u, keyword, found)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: keyword\n  logical, intent(out) :: found\n  character(len=256) :: line\n  integer :: ios\n  found = .false.\n  rewind(u)\n  do\n    read(u, '(A)', iostat=ios) line\n    if (ios /= 0) exit\n    if (index(line, trim(keyword)) > 0) then\n      found = .true.\n      exit\n    end if\n  end do\nend subroutine read_until_keyword_found",
        "summary": "Searches a file connected to unit `u` for a specific keyword string by rewinding to the beginning and reading line-by-line until the keyword is found or the end of the file is reached."
    },
    {
        "id": 431,
        "code": "program append_to_csv\n  implicit none\n  integer :: u\n  character(len=20) :: name = 'Item_X'\n  integer :: qty = 50\n  open(newunit=u, file='inventory.csv', status='old', position='append')\n  write(u, '(A, \",\", I0)') trim(name), qty\n  close(u)\nend program append_to_csv",
        "summary": "Opens an existing CSV file in append mode and adds a new record consisting of a name and quantity, separated by a comma, to the end of the file."
    },
    {
        "id": 432,
        "code": "subroutine write_error_and_stop(msg)\n  implicit none\n  character(len=*), intent(in) :: msg\n  write(0, '(A, A)') 'FATAL ERROR: ', trim(msg)\n  stop 1\nend subroutine write_error_and_stop",
        "summary": "Writes a fatal error message to the standard error output (unit 0) and immediately terminates the program execution with a non-zero exit code."
    },
    {
        "id": 433,
        "code": "program read_complex_numbers\n  implicit none\n  integer :: u, i\n  complex :: z_array(5)\n  open(newunit=u, file='complex_data.txt')\n  read(u, *) (z_array(i), i=1,5)\n  print *, 'First complex number:', z_array(1)\n  close(u)\nend program read_complex_numbers",
        "summary": "Reads five complex numbers from a file using list-directed input, storing them in an array, and prints the first complex value to the standard output."
    },
    {
        "id": 434,
        "code": "subroutine safe_rewind(u)\n  implicit none\n  integer, intent(in) :: u\n  logical :: is_open\n  inquire(unit=u, opened=is_open)\n  if (is_open) then\n    rewind(u)\n  else\n    print *, 'Warning: Attempted to rewind closed unit', u\n  end if\nend subroutine safe_rewind",
        "summary": "Checks if a unit is currently open before attempting to rewind it; if the unit is closed, it prints a warning instead of causing a runtime error."
    },
    {
        "id": 435,
        "code": "program write_integer_sequence\n  implicit none\n  integer :: u, i\n  open(newunit=u, file='sequence.txt', status='replace')\n  do i = 1, 100\n    write(u, '(I0)', advance='no') i\n    if (mod(i, 10) == 0) write(u, *) ! Newline every 10 numbers\n    if (mod(i, 10) /= 0) write(u, '(1X)', advance='no') ! Space otherwise\n  end do\n  close(u)\nend program write_integer_sequence",
        "summary": "Writes numbers 1 to 100 to a file, formatting them such that 10 numbers appear per line, separated by spaces, by manually controlling newline generation with `advance='no'`."
    },
    {
        "id": 436,
        "code": "subroutine check_write_access_file(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  character(len=20) :: write_perm\n  inquire(file=fname, write=write_perm)\n  if (trim(write_perm) == 'NO') then\n    print *, 'File is read-only or permission denied.'\n  end if\nend subroutine check_write_access_file",
        "summary": "Queries the write permissions of a specific file and prints a message if the file is determined to be read-only or if write permission is denied."
    },
    {
        "id": 437,
        "code": "program read_stream_byte_chunks\n  implicit none\n  integer :: u, ios\n  character(len=1024) :: chunk\n  open(newunit=u, file='large_data.bin', access='stream', status='old')\n  do\n    read(u, iostat=ios) chunk\n    if (ios /= 0) exit\n    ! process chunk here\n  end do\n  close(u)\nend program read_stream_byte_chunks",
        "summary": "Reads a binary file in 1024-byte chunks using stream access in a loop until the end of the file is reached, allowing for processing of large files without loading them entirely into memory."
    },
    {
        "id": 438,
        "code": "subroutine backup_file(src, dest)\n  implicit none\n  character(len=*), intent(in) :: src, dest\n  character(len=512) :: cmd\n  write(cmd, '(\"cp \", A, \" \", A)') trim(src), trim(dest)\n  call execute_command_line(trim(cmd))\nend subroutine backup_file",
        "summary": "Creates a backup of a file by constructing a shell command string (e.g., 'cp src dest') and executing it using the `execute_command_line` intrinsic subroutine."
    },
    {
        "id": 439,
        "code": "program verify_namelist_write\n  implicit none\n  integer :: id = 101\n  real :: score = 95.5\n  namelist /student_info/ id, score\n  integer :: u\n  open(newunit=u, file='output.nml', status='replace')\n  write(u, nml=student_info)\n  close(u)\n  print *, 'Namelist written to output.nml'\nend program verify_namelist_write",
        "summary": "Initializes variables `id` and `score`, assigns them to a namelist group `student_info`, and writes the namelist to a file named 'output.nml', which will produce a labeled output format suitable for configuration files."
    },
    {
        "id": 440,
        "code": "subroutine set_decimal_separator_comma(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, decimal='COMMA')\nend subroutine set_decimal_separator_comma",
        "summary": "Modifies the properties of an open I/O unit to use a comma (',') as the decimal separator instead of a period, which is common in European numeric formats."
    },
    {
        "id": 441,
        "code": "program count_lines_in_file\n  implicit none\n  integer :: u, count, ios\n  open(newunit=u, file='dataset.txt', status='old')\n  count = 0\n  do\n    read(u, *, iostat=ios)\n    if (ios /= 0) exit\n    count = count + 1\n  end do\n  print *, 'Total lines:', count\n  close(u)\nend program count_lines_in_file",
        "summary": "Opens 'dataset.txt' and iterates through the file by reading dummy records until the end-of-file is detected, maintaining a counter to determine the total number of lines."
    },
    {
        "id": 442,
        "code": "subroutine write_padded_string(u, str, width)\n  implicit none\n  integer, intent(in) :: u, width\n  character(len=*), intent(in) :: str\n  character(len=20) :: fmt\n  write(fmt, '(\"(A\", I0, \")\")') width\n  write(u, fmt) trim(str)\nend subroutine write_padded_string",
        "summary": "Writes a string to a file using a dynamic format that pads the output with spaces to ensure it occupies a specific fixed width."
    },
    {
        "id": 443,
        "code": "program check_unformatted_support\n  implicit none\n  character(len=20) :: unf_status\n  inquire(file='binary.dat', unformatted=unf_status)\n  if (trim(unf_status) == 'YES') then\n    print *, 'Unformatted I/O is supported.'\n  end if\nend program check_unformatted_support",
        "summary": "Checks if the file 'binary.dat' supports unformatted (binary) Input/Output operations by querying the `unformatted` property via the `inquire` statement."
    },
    {
        "id": 444,
        "code": "subroutine skip_header_lines(u, n)\n  implicit none\n  integer, intent(in) :: u, n\n  integer :: i\n  do i = 1, n\n    read(u, *) ! Reading without list skips the record\n  end do\nend subroutine skip_header_lines",
        "summary": "Reads and discards the first `n` lines from an open file unit, commonly used to skip metadata or header rows before processing the actual data."
    },
    {
        "id": 445,
        "code": "program read_utf8_char\n  implicit none\n  integer :: u\n  character(len=1, kind=selected_char_kind('ISO_10646')) :: c\n  open(newunit=u, file='utf8.txt', encoding='UTF-8', status='old')\n  read(u, '(A)') c\n  print *, 'First UTF-8 char read.'\n  close(u)\nend program read_utf8_char",
        "summary": "Opens a text file explicitly specifying 'UTF-8' encoding and reads a single character into a variable of the appropriate kind (`ISO_10646`), ensuring correct handling of Unicode characters."
    },
    {
        "id": 446,
        "code": "subroutine write_list_to_file(fname, data, n)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(in) :: n\n  real, dimension(n), intent(in) :: data\n  integer :: u, i\n  open(newunit=u, file=fname, status='replace')\n  do i = 1, n\n    write(u, *) data(i)\n  end do\n  close(u)\nend subroutine write_list_to_file",
        "summary": "Creates or overwrites a file with the given filename and writes the elements of a real-valued array to it, placing each element on a new line."
    },
    {
        "id": 447,
        "code": "program check_file_locked\n  implicit none\n  logical :: opened_by_me\n  inquire(file='shared.lock', opened=opened_by_me)\n  if (opened_by_me) then\n    print *, 'File is already opened by this program.'\n  else\n    print *, 'File is not currently opened by this program.'\n  end if\nend program check_file_locked",
        "summary": "Determines if the file 'shared.lock' is currently open by the running program instance using the `inquire` statement's `opened` parameter."
    },
    {
        "id": 448,
        "code": "subroutine read_specific_line_number(fname, target_line, content)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(in) :: target_line\n  character(len=256), intent(out) :: content\n  integer :: u, i\n  open(newunit=u, file=fname, status='old')\n  do i = 1, target_line - 1\n    read(u, *) ! Skip lines\n  end do\n  read(u, '(A)') content\n  close(u)\nend subroutine read_specific_line_number",
        "summary": "Opens a file and loops to skip `target_line - 1` records, then reads the content of the specific requested line number into the output variable before closing the file."
    },
    {
        "id": 449,
        "code": "program write_tab_separated_values\n  implicit none\n  integer :: u\n  character(len=1) :: tab\n  tab = char(9)\n  open(newunit=u, file='data.tsv', status='replace')\n  write(u, '(A, A, A, A, I3)') 'Name', tab, 'Role', tab, 101\n  close(u)\nend program write_tab_separated_values",
        "summary": "Writes a single row of data to 'data.tsv', explicitly inserting ASCII tab characters (char 9) between fields to adhere to the TSV (Tab-Separated Values) format."
    },
    {
        "id": 450,
        "code": "subroutine flush_and_sync(u)\n  implicit none\n  integer, intent(in) :: u\n  flush(u)\n  print *, 'Buffer flushed for unit', u\nend subroutine flush_and_sync",
        "summary": "Explicitly flushes the I/O buffer associated with the given unit to disk, ensuring that all pending write operations are physically committed, and prints a confirmation."
    },
    {
        "id": 451,
        "code": "program read_with_error_recovery\n  implicit none\n  integer :: u, val\n  open(newunit=u, file='numbers.txt', status='old')\n  do\n    read(u, *, err=100, end=200) val\n    print *, 'Read:', val\n    cycle\n100 print *, 'Skipping malformed line.'\n  end do\n200 close(u)\nend program read_with_error_recovery",
        "summary": "Reads integers from a file in a loop; if a formatting error occurs (e.g., non-numeric data), control jumps to label 100 to print a warning and continue, while end-of-file jumps to label 200 to exit cleanly."
    },
    {
        "id": 452,
        "code": "subroutine write_environment_variable(u, var_name)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: var_name\n  character(len=256) :: value\n  call get_environment_variable(var_name, value)\n  write(u, '(A, \"=\", A)') trim(var_name), trim(value)\nend subroutine write_environment_variable",
        "summary": "Retrieves the value of a system environment variable using `get_environment_variable` and writes it to the specified file unit in `KEY=VALUE` format."
    },
    {
        "id": 453,
        "code": "program direct_access_read_write\n  implicit none\n  integer :: u, rec_len\n  real :: val\n  rec_len = 4 ! 4 bytes for default real\n  open(newunit=u, file='random.dat', access='direct', recl=rec_len, status='replace')\n  write(u, rec=1) 1.1\n  write(u, rec=10) 9.9\n  read(u, rec=1) val\n  print *, 'Record 1 contains:', val\n  close(u)\nend program direct_access_read_write",
        "summary": "Demonstrates direct access file manipulation by writing real numbers to the 1st and 10th records (leaving others undefined) and then reading the 1st record back to verify the operation."
    },
    {
        "id": 454,
        "code": "subroutine check_and_create_dir(dirname)\n  implicit none\n  character(len=*), intent(in) :: dirname\n  ! Fortran standard doesn't have native mkdir, usually requires system call\n  call execute_command_line('mkdir -p ' // trim(dirname))\nend subroutine check_and_create_dir",
        "summary": "Executes a system shell command (`mkdir -p`) to create a directory and its parents if they do not exist, as directory manipulation is not part of the standard Fortran I/O library."
    },
    {
        "id": 455,
        "code": "program read_lines_to_eof\n  implicit none\n  integer :: u, iostat\n  character(len=100) :: line\n  open(newunit=u, file='config.txt')\n  do\n    read(u, '(A)', iostat=iostat) line\n    if (is_iostat_end(iostat)) exit\n    print *, 'Line:', trim(line)\n  end do\n  close(u)\nend program read_lines_to_eof",
        "summary": "Reads a file line by line until the `is_iostat_end` intrinsic function returns true, printing each line's content to the standard output."
    },
    {
        "id": 456,
        "code": "subroutine write_fixed_header(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A10, A10, A10)') 'ID', 'X-Value', 'Y-Value'\n  write(u, '(A)') repeat('-', 30)\nend subroutine write_fixed_header",
        "summary": "Writes a table header with three columns, each 10 characters wide, followed by a separator line of 30 dashes, to the specified file unit."
    },
    {
        "id": 457,
        "code": "program inquire_iolength_test\n  implicit none\n  integer :: io_len\n  type :: particle\n    real :: x, y, z\n    integer :: id\n  end type particle\n  type(particle) :: p\n  inquire(iolength=io_len) p\n  print *, 'Bytes required for particle record:', io_len\nend program inquire_iolength_test",
        "summary": "Calculates the precise record length required to store a derived type `particle` (containing three reals and one integer) in an unformatted file using the `inquire(iolength=...)` feature."
    },
    {
        "id": 458,
        "code": "subroutine set_blank_interpretation(u, mode)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: mode\n  if (trim(mode) == 'ZERO') then\n    open(unit=u, blank='ZERO')\n  else\n    open(unit=u, blank='NULL')\n  end if\nend subroutine set_blank_interpretation",
        "summary": "Changes the interpretation of blank spaces in numeric input fields for an open unit; setting it to 'ZERO' treats blanks as zeros, while 'NULL' (default) ignores them."
    },
    {
        "id": 459,
        "code": "program write_stdout_prompt\n  implicit none\n  write(*, '(A)', advance='no') 'Enter your name: '\n  ! Cursor stays at end of prompt\nend program write_stdout_prompt",
        "summary": "Writes a prompt string to the standard output (unit `*`) using non-advancing I/O, which ensures the user's cursor remains on the same line awaiting input."
    },
    {
        "id": 460,
        "code": "subroutine check_read_write_perms(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  character(len=20) :: rd, wr\n  inquire(file=fname, read=rd, write=wr)\n  print *, 'File: ', trim(fname)\n  print *, 'Readable: ', trim(rd)\n  print *, 'Writable: ', trim(wr)\nend subroutine check_read_write_perms",
        "summary": "Inquires about both the read and write permissions of a specified file and prints the results (e.g., 'YES', 'NO', or 'UNKNOWN') to standard output."
    },
    {
        "id": 461,
        "code": "program read_string_into_int\n  implicit none\n  character(len=10) :: str_val = '  12345   '\n  integer :: int_val\n  read(str_val, '(I10)') int_val\n  print *, 'Converted integer:', int_val\nend program read_string_into_int",
        "summary": "Performs an internal read to parse an integer from a string variable `str_val` using a fixed format `I10`, converting the text representation into a numeric integer value."
    },
    {
        "id": 462,
        "code": "subroutine delete_file_by_unit(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u, status='delete')\nend subroutine delete_file_by_unit",
        "summary": "Closes the specified file unit with the status 'delete', which causes the associated file to be removed from the file system immediately."
    },
    {
        "id": 463,
        "code": "program check_asynchronous_io\n  implicit none\n  character(len=20) :: async_status\n  inquire(unit=10, asynchronous=async_status)\n  if (trim(async_status) == 'YES') then\n    print *, 'Unit 10 supports asynchronous I/O.'\n  end if\nend program check_asynchronous_io",
        "summary": "Checks if unit 10 is currently configured to support asynchronous Input/Output, allowing the program to continue execution while I/O operations complete in the background."
    },
    {
        "id": 464,
        "code": "subroutine write_csv_record(u, id, val)\n  implicit none\n  integer, intent(in) :: u, id\n  real, intent(in) :: val\n  write(u, '(I0, \",\", F10.2)') id, val\nend subroutine write_csv_record",
        "summary": "Writes a single record to a CSV file consisting of an integer ID and a real value formatted with two decimal places, separated by a comma."
    },
    {
        "id": 465,
        "code": "program read_until_eor\n  implicit none\n  integer :: u, val, ios\n  open(newunit=u, file='data.txt')\n  read(u, '(I5)', advance='no', eor=10, iostat=ios) val\n  print *, 'Read value:', val\n  stop\n10 print *, 'End of record encountered before read completion.'\nend program read_until_eor",
        "summary": "Attempts a non-advancing read of an integer; if the end of the record (line) is reached before the read completes, execution jumps to label 10 to handle the EOR condition."
    },
    {
        "id": 466,
        "code": "subroutine print_dashes_separator(u, n)\n  implicit none\n  integer, intent(in) :: u, n\n  character(len=100) :: dashes\n  dashes = repeat('-', n)\n  write(u, '(A)') trim(dashes)\nend subroutine print_dashes_separator",
        "summary": "Generates a string of `n` dashes and writes it to the specified unit `u` to serve as a visual separator or underline in text output."
    },
    {
        "id": 467,
        "code": "program check_encoding_scheme\n  implicit none\n  character(len=20) :: enc\n  inquire(file='text.txt', encoding=enc)\n  print *, 'File encoding is reported as: ', trim(enc)\nend program check_encoding_scheme",
        "summary": "Inquires about the character encoding scheme (e.g., 'UTF-8', 'DEFAULT', or 'UNKNOWN') of 'text.txt' and prints the result."
    },
    {
        "id": 468,
        "code": "subroutine open_new_scratch_file(u)\n  implicit none\n  integer, intent(out) :: u\n  open(newunit=u, status='scratch')\n  print *, 'Opened temporary scratch unit:', u\nend subroutine open_new_scratch_file",
        "summary": "Opens a new scratch file (a temporary file that is automatically deleted when closed) and returns the automatically assigned unit number to the caller."
    },
    {
        "id": 469,
        "code": "program read_stream_position\n  implicit none\n  integer :: u, pos\n  character :: c\n  open(newunit=u, file='data.bin', access='stream')\n  read(u) c\n  inquire(unit=u, pos=pos)\n  print *, 'Current byte position after read:', pos\n  close(u)\nend program read_stream_position",
        "summary": "Reads a single byte from a stream-access file and then uses `inquire(pos=...)` to determine the current file pointer position (in bytes) immediately after the read."
    },
    {
        "id": 470,
        "code": "subroutine set_sign_plus_mode(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, sign='PLUS')\nend subroutine set_sign_plus_mode",
        "summary": "Configures an open I/O unit to always include a plus sign ('+') for positive numbers in formatted output, overriding the default behavior of suppressing it."
    },
    {
        "id": 471,
        "code": "program read_allocatable_string_line\n  implicit none\n  integer :: u\n  character(len=:), allocatable :: line_content\n  character(len=1000) :: temp_buf\n  open(newunit=u, file='long_lines.txt')\n  read(u, '(A)') temp_buf\n  line_content = trim(temp_buf)\n  print *, 'Line length:', len(line_content)\n  close(u)\nend program read_allocatable_string_line",
        "summary": "Reads a line from a file into a large temporary buffer, trims the trailing whitespace, and assigns the result to an allocatable string, effectively sizing the string to match the content."
    },
    {
        "id": 472,
        "code": "subroutine write_matrix_row_by_row(u, mat, rows, cols)\n  implicit none\n  integer, intent(in) :: u, rows, cols\n  real, dimension(rows, cols), intent(in) :: mat\n  integer :: i\n  do i = 1, rows\n    write(u, *) mat(i, :)\n  end do\nend subroutine write_matrix_row_by_row",
        "summary": "Iterates through the rows of a 2D array (matrix) and writes each row to the specified file unit on a new line using list-directed formatting."
    },
    {
        "id": 473,
        "code": "program check_pad_mode\n  implicit none\n  character(len=20) :: pad_status\n  inquire(unit=10, pad=pad_status)\n  if (trim(pad_status) == 'NO') then\n    print *, 'Input padding is disabled for unit 10.'\n  end if\nend program check_pad_mode",
        "summary": "Checks if the padding property for unit 10 is set to 'NO', which means the program will not implicitly pad short records with blanks during formatted reads."
    },
    {
        "id": 474,
        "code": "subroutine write_quoted_output(u, txt)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: txt\n  write(u, '(A, A, A)') '\"', trim(txt), '\"'\nend subroutine write_quoted_output",
        "summary": "Writes the provided text string to the specified unit enclosed in double quotation marks, useful for generating CSV or JSON-like output."
    },
    {
        "id": 475,
        "code": "program read_list_integers_loop\n  implicit none\n  integer :: u, val, ios\n  open(newunit=u, file='integers.txt')\n  do\n    read(u, *, iostat=ios) val\n    if (ios /= 0) exit\n    print *, val\n  end do\n  close(u)\nend program read_list_integers_loop",
        "summary": "Reads integer values one by one from 'integers.txt' using list-directed input (which handles spaces/newlines automatically) until an error or EOF is encountered."
    },
    {
        "id": 476,
        "code": "subroutine open_read_only_if_exists(fname, u, status)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer, intent(out) :: u, status\n  logical :: exists\n  inquire(file=fname, exist=exists)\n  if (exists) then\n    open(newunit=u, file=fname, status='old', action='read', iostat=status)\n  else\n    status = -1\n  end if\nend subroutine open_read_only_if_exists",
        "summary": "Checks if a file exists; if it does, it attempts to open it in read-only mode and returns the unit number and I/O status; if not, it returns a custom error status (-1)."
    },
    {
        "id": 477,
        "code": "program formatted_write_rounding\n  implicit none\n  integer :: u\n  real :: val = 0.666\n  open(newunit=u, file='data.txt', round='UP')\n  write(u, '(F5.2)') val\n  close(u)\nend program formatted_write_rounding",
        "summary": "Opens a file with the rounding mode set to 'UP' and writes a real number `0.666` formatted to two decimal places, which forces the output to round away from zero (0.67)."
    },
    {
        "id": 478,
        "code": "subroutine skip_lines_simple(u, n)\n  implicit none\n  integer, intent(in) :: u, n\n  integer :: i\n  do i = 1, n\n    read(u, *)\n  end do\nend subroutine skip_lines_simple",
        "summary": "Performs a loop `n` times to read and discard lines from the connected file unit `u`, effectively advancing the read pointer past `n` records."
    },
    {
        "id": 479,
        "code": "program read_logical_values\n  implicit none\n  integer :: u\n  logical :: val\n  open(newunit=u, file='flags.txt')\n  read(u, *) val\n  if (val) print *, 'Flag is true'\n  close(u)\nend program read_logical_values",
        "summary": "Reads a logical value from 'flags.txt' (expecting T, F, .TRUE., or .FALSE. in the file) and prints a message if the value evaluates to true."
    },
    {
        "id": 480,
        "code": "subroutine close_if_connected(u)\n  implicit none\n  integer, intent(in) :: u\n  logical :: connected\n  inquire(unit=u, opened=connected)\n  if (connected) close(u)\nend subroutine close_if_connected",
        "summary": "Safely closes a file unit by first inquiring if it is actually connected (opened); if it is not open, the subroutine does nothing, preventing runtime errors."
    },
    {
        "id": 481,
        "code": "program check_direct_access_recl\n  implicit none\n  integer :: rlen\n  inquire(file='database.dat', recl=rlen)\n  print *, 'Record length for database.dat is:', rlen\nend program check_direct_access_recl",
        "summary": "Inquires about the record length (`recl`) property of the file 'database.dat', which is critical information when opening existing direct-access files."
    },
    {
        "id": 482,
        "code": "subroutine write_blank_line_separator(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, *)\nend subroutine write_blank_line_separator",
        "summary": "Writes a single empty record (a blank line) to the specified unit `u`, often used to separate sections of data in text output."
    },
    {
        "id": 483,
        "code": "program read_char_non_advancing_loop\n  implicit none\n  integer :: u, ios\n  character :: c\n  open(newunit=u, file='data.txt')\n  do\n    read(u, '(A1)', advance='no', iostat=ios) c\n    if (ios /= 0) exit\n    write(*, *) 'Char:', c\n  end do\n  close(u)\nend program read_char_non_advancing_loop",
        "summary": "Reads a file character-by-character using non-advancing I/O (`advance='no'`) inside a loop until an error or EOF occurs, printing each character individually."
    },
    {
        "id": 484,
        "code": "subroutine set_decimal_point_format(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, decimal='POINT')\nend subroutine set_decimal_point_format",
        "summary": "Configures the specified open unit to use a period ('.') as the decimal separator for numeric formatting, which is the standard US/UK format."
    },
    {
        "id": 485,
        "code": "program check_file_name_by_unit\n  implicit none\n  character(len=128) :: fname\n  inquire(unit=10, name=fname)\n  print *, 'Unit 10 is connected to file: ', trim(fname)\nend program check_file_name_by_unit",
        "summary": "Inquires the name of the file currently connected to unit 10 and prints the filename to standard output, useful for debugging file connections."
    },
    {
        "id": 486,
        "code": "subroutine write_int_array_one_line(u, arr)\n  implicit none\n  integer, intent(in) :: u\n  integer, dimension(:), intent(in) :: arr\n  write(u, *) arr\nend subroutine write_int_array_one_line",
        "summary": "Writes an entire integer array to the file unit `u` using list-directed output, which typically places as many elements as fit on a single line before wrapping."
    },
    {
        "id": 487,
        "code": "program read_scalar_value\n  implicit none\n  integer :: u\n  real :: scalar\n  open(newunit=u, file='param.txt')\n  read(u, *) scalar\n  print *, 'Parameter value:', scalar\n  close(u)\nend program read_scalar_value",
        "summary": "Opens 'param.txt' and reads a single real-valued scalar number from the beginning of the file, assuming it is the first item present."
    },
    {
        "id": 488,
        "code": "subroutine rewind_and_clear(fname)\n  implicit none\n  character(len=*), intent(in) :: fname\n  integer :: u\n  open(newunit=u, file=fname, status='old')\n  close(u, status='delete')\n  ! Recreate empty\n  open(newunit=u, file=fname, status='new')\n  close(u)\nend subroutine rewind_and_clear",
        "summary": "Effectively clears a file's content by opening it, deleting it, and then immediately creating a new, empty file with the same name."
    },
    {
        "id": 489,
        "code": "program check_action_readwrite\n  implicit none\n  character(len=20) :: act\n  inquire(file='data.db', action=act)\n  if (trim(act) == 'READWRITE') then\n    print *, 'File open for both reading and writing.'\n  end if\nend program check_action_readwrite",
        "summary": "Checks if 'data.db' is currently opened with 'READWRITE' privileges, allowing both input and output operations on the same unit."
    },
    {
        "id": 490,
        "code": "subroutine write_scientific_notation(u, val)\n  implicit none\n  integer, intent(in) :: u\n  real, intent(in) :: val\n  write(u, '(ES12.5)') val\nend subroutine write_scientific_notation",
        "summary": "Writes a real value to the specified unit using scientific notation (ES format) with 5 decimal places of precision and a total width of 12 characters."
    },
    {
        "id": 491,
        "code": "program read_error_check_label\n  implicit none\n  integer :: u\n  open(newunit=u, file='missing_file.txt', status='old', err=10)\n  print *, 'File opened successfully.'\n  stop\n10 print *, 'Error: File could not be opened.'\nend program read_error_check_label",
        "summary": "Attempts to open a file and uses the `err=label` syntax to redirect program control to label 10 if the open operation fails, preventing a crash."
    },
    {
        "id": 492,
        "code": "subroutine append_log_message(msg)\n  implicit none\n  character(len=*), intent(in) :: msg\n  integer :: u\n  open(newunit=u, file='app.log', position='append', status='unknown')\n  write(u, '(A)') trim(msg)\n  close(u)\nend subroutine append_log_message",
        "summary": "Opens 'app.log' in append mode (creating it if it doesn't exist via `status='unknown'`) and writes the provided message to the end of the file."
    },
    {
        "id": 493,
        "code": "program check_delim_quote\n  implicit none\n  character(len=20) :: del\n  inquire(unit=10, delim=del)\n  if (trim(del) == 'QUOTE') print *, 'Delimiters are quotes.'\nend program check_delim_quote",
        "summary": "Checks if the delimiter mode for unit 10 is set to 'QUOTE', meaning character strings in list-directed output will be enclosed in double quotes."
    },
    {
        "id": 494,
        "code": "subroutine write_comma_no_newline(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)', advance='no') ','\nend subroutine write_comma_no_newline",
        "summary": "Writes a comma character to the specified unit using non-advancing I/O, preventing the cursor from moving to the next line."
    },
    {
        "id": 495,
        "code": "program read_stream_chunk_buffer\n  implicit none\n  integer :: u\n  character(len=512) :: buffer\n  open(newunit=u, file='data.bin', access='stream')\n  read(u) buffer\n  print *, 'Read 512-byte chunk.'\n  close(u)\nend program read_stream_chunk_buffer",
        "summary": "Reads exactly 512 bytes of data from a stream-access file into a character buffer, useful for block-processing binary files."
    },
    {
        "id": 496,
        "code": "subroutine set_round_down_mode(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, round='DOWN')\nend subroutine set_round_down_mode",
        "summary": "Sets the rounding mode of the open unit `u` to 'DOWN', causing numeric output to be rounded towards negative infinity."
    },
    {
        "id": 497,
        "code": "program check_seq_access_support\n  implicit none\n  character(len=20) :: seq\n  inquire(file='tape.dat', sequential=seq)\n  if (trim(seq) == 'YES') print *, 'Sequential access supported.'\nend program check_seq_access_support",
        "summary": "Verifies if the file 'tape.dat' supports sequential access (the default mode for text files) by querying the `sequential` property."
    },
    {
        "id": 498,
        "code": "subroutine write_integer_width_fixed(u, val)\n  implicit none\n  integer, intent(in) :: u, val\n  write(u, '(I5)') val\nend subroutine write_integer_width_fixed",
        "summary": "Writes an integer value to the specified unit using a fixed field width of 5 characters, padding with spaces on the left if necessary."
    },
    {
        "id": 499,
        "code": "program read_internal_file_string\n  implicit none\n  character(len=20) :: input = ' 10 20.5 '\n  integer :: i\n  real :: r\n  read(input, *) i, r\n  print *, 'Int:', i, ' Real:', r\nend program read_internal_file_string",
        "summary": "Uses a character string variable (`input`) as an internal file to read an integer and a real number, parsing the data from memory rather than disk."
    },
    {
        "id": 500,
        "code": "subroutine check_io_error_status(ios)\n  implicit none\n  integer, intent(in) :: ios\n  if (ios /= 0) then\n    print *, 'I/O Error occurred. Code:', ios\n  end if\nend subroutine check_io_error_status",
        "summary": "Checks the integer I/O status code (`ios`); if it is non-zero (indicating an error or EOF), it prints a message containing the error code."
    },
    {
        "id": 501,
        "code": "program read_namelist_group_data\n  implicit none\n  integer :: a, b\n  namelist /my_group/ a, b\n  integer :: u\n  open(newunit=u, file='data.nml')\n  read(u, nml=my_group)\n  close(u)\n  print *, 'Read A:', a, ' B:', b\nend program read_namelist_group_data",
        "summary": "Reads variables `a` and `b` belonging to the namelist group `my_group` from the file 'data.nml', automatically matching variable names in the file to program variables."
    },
    {
        "id": 502,
        "code": "subroutine write_simple_title(u, title)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: title\n  write(u, *) trim(title)\nend subroutine write_simple_title",
        "summary": "Writes the provided title string to the specified unit using list-directed output, trimming any trailing whitespace from the title."
    },
    {
        "id": 503,
        "code": "program check_stream_access_mode\n  implicit none\n  character(len=20) :: acc\n  inquire(file='data.bin', access=acc)\n  if (trim(acc) == 'STREAM') print *, 'File uses stream access.'\nend program check_stream_access_mode",
        "summary": "Inquires about the access mode of 'data.bin' to determine if it is currently treated as a 'STREAM' file."
    },
    {
        "id": 504,
        "code": "subroutine write_quoted_string_val(u, s)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: s\n  write(u, '(\"' // \"'\" // '\", A, \"' // \"'\" // '\")') trim(s)\nend subroutine write_quoted_string_val",
        "summary": "Writes a string value to the file unit enclosed in single quotes, dynamically constructing the format string to handle the quote characters."
    },
    {
        "id": 505,
        "code": "program read_skip_one_record\n  implicit none\n  integer :: u, val\n  open(newunit=u, file='data.txt')\n  read(u, *) ! Skip first record\n  read(u, *) val\n  print *, 'Value from 2nd record:', val\n  close(u)\nend program read_skip_one_record",
        "summary": "Opens a file, executes a dummy read to skip the first record, and then reads an integer value from the second record."
    },
    {
        "id": 506,
        "code": "subroutine set_round_zero_mode(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, round='ZERO')\nend subroutine set_round_zero_mode",
        "summary": "Sets the rounding mode for the unit to 'ZERO', ensuring that formatted numeric output is truncated towards zero rather than rounded to the nearest value."
    },
    {
        "id": 507,
        "code": "program check_exist_file_path\n  implicit none\n  logical :: exists\n  inquire(file='/tmp/data.log', exist=exists)\n  if (exists) print *, 'Log file found.'\nend program check_exist_file_path",
        "summary": "Checks for the existence of a file at a specific absolute path ('/tmp/data.log') and prints a confirmation if found."
    },
    {
        "id": 508,
        "code": "subroutine write_end_marker(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, *) '--- END ---'\nend subroutine write_end_marker",
        "summary": "Writes a specific end-of-data marker string ('--- END ---') to the file unit to signify the conclusion of a data section."
    },
    {
        "id": 509,
        "code": "program read_double_precision_val\n  implicit none\n  integer :: u\n  double precision :: val\n  open(newunit=u, file='precise.txt')\n  read(u, *) val\n  print *, 'Precision value:', val\n  close(u)\nend program read_double_precision_val",
        "summary": "Reads a double precision floating-point number from 'precise.txt' using list-directed input, preserving high precision."
    },
    {
        "id": 510,
        "code": "subroutine close_unit_connection(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u)\nend subroutine close_unit_connection",
        "summary": "Simply closes the specified file unit, terminating the connection and saving the file state."
    },
    {
        "id": 511,
        "code": "program check_file_size_bytes\n  implicit none\n  integer :: file_size\n  inquire(file='image.png', size=file_size)\n  print *, 'Size in bytes:', file_size\nend program check_file_size_bytes",
        "summary": "Queries the size of 'image.png' in bytes using the `size` specifier of the inquire statement and prints the result."
    },
    {
        "id": 512,
        "code": "subroutine write_integer_val(u, i)\n  implicit none\n  integer, intent(in) :: u, i\n  write(u, *) i\nend subroutine write_integer_val",
        "summary": "Writes a single integer value to the specified unit using default list-directed formatting."
    },
    {
        "id": 513,
        "code": "program handle_read_error\n  implicit none\n  integer :: u, val, ios\n  open(newunit=u, file='data.txt')\n  read(u, *, iostat=ios) val\n  if (ios /= 0) print *, 'Error reading file.'\n  close(u)\nend program handle_read_error",
        "summary": "Attempts to read a value from 'data.txt' capturing the status in `ios`; if `ios` is non-zero, it reports a read error."
    },
    {
        "id": 514,
        "code": "subroutine open_scratch_file(u)\n  implicit none\n  integer, intent(out) :: u\n  open(newunit=u, status='scratch')\nend subroutine open_scratch_file",
        "summary": "Opens a temporary scratch file that will be automatically deleted upon closing, returning the unit number."
    },
    {
        "id": 515,
        "code": "program check_delim_none_mode\n  implicit none\n  character(len=20) :: del\n  inquire(unit=10, delim=del)\n  if (trim(del) == 'NONE') print *, 'No delimiters set.'\nend program check_delim_none_mode",
        "summary": "Checks if the delimiter mode for unit 10 is 'NONE', meaning strings will be written without quotes in list-directed output."
    },
    {
        "id": 516,
        "code": "subroutine write_label_colon(u, label)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: label\n  write(u, '(A, \": \")', advance='no') trim(label)\nend subroutine write_label_colon",
        "summary": "Writes a label followed by a colon and a space to the unit without advancing to the next line, suitable for prompts or key-value pairs."
    },
    {
        "id": 517,
        "code": "program read_partial_record_int\n  implicit none\n  integer :: u, i\n  open(newunit=u, file='data.txt')\n  read(u, '(I5)', advance='no') i\n  print *, 'Partial read:', i\n  close(u)\nend program read_partial_record_int",
        "summary": "Reads an integer from the first 5 characters of a record using non-advancing I/O, leaving the file pointer in the middle of the line."
    },
    {
        "id": 518,
        "code": "subroutine write_eof_record(u)\n  implicit none\n  integer, intent(in) :: u\n  endfile(u)\nend subroutine write_eof_record",
        "summary": "Writes a special End-Of-File record to the current position of the specified unit, effectively truncating the file at that point."
    },
    {
        "id": 519,
        "code": "program check_formatted_access\n  implicit none\n  character(len=20) :: fmt\n  inquire(file='doc.txt', formatted=fmt)\n  if (trim(fmt) == 'YES') print *, 'Formatted access OK.'\nend program check_formatted_access",
        "summary": "Checks if 'doc.txt' supports formatted access (text mode) and prints a confirmation if successful."
    },
    {
        "id": 520,
        "code": "subroutine write_log_entry(u, msg)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: msg\n  write(u, '(A, A)') 'LOG: ', trim(msg)\nend subroutine write_log_entry",
        "summary": "Writes a log entry to the specified unit, prefixing the provided message with 'LOG: '."
    },
    {
        "id": 521,
        "code": "program check_opened_by_file\n  implicit none\n  logical :: op\n  inquire(file='in_use.dat', opened=op)\n  if (op) print *, 'File is currently open.'\nend program check_opened_by_file",
        "summary": "Checks if the file 'in_use.dat' is currently connected (open) in the running program."
    },
    {
        "id": 522,
        "code": "subroutine write_dash_char(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)') '-'\nend subroutine write_dash_char",
        "summary": "Writes a single dash character on a new line to the specified unit."
    },
    {
        "id": 523,
        "code": "program check_unformatted_seq_access\n  implicit none\n  character(len=20) :: unf\n  inquire(file='data.bin', unformatted=unf)\n  if (trim(unf) == 'YES') print *, 'Unformatted access OK.'\nend program check_unformatted_seq_access",
        "summary": "Verifies if 'data.bin' supports unformatted (binary) access and prints a message if allowed."
    },
    {
        "id": 524,
        "code": "subroutine open_append_file(u, fname)\n  implicit none\n  integer, intent(out) :: u\n  character(len=*), intent(in) :: fname\n  open(newunit=u, file=fname, position='append', status='old')\nend subroutine open_append_file",
        "summary": "Opens an existing file in 'append' mode, ensuring that any new data written will be added to the end of the file."
    },
    {
        "id": 525,
        "code": "program read_next_record_skip\n  implicit none\n  integer :: u\n  open(newunit=u, file='data.txt')\n  read(u, *) ! Skips next record\n  close(u)\nend program read_next_record_skip",
        "summary": "Opens a file and performs a single dummy read operation to advance the file pointer past the first record."
    },
    {
        "id": 526,
        "code": "subroutine close_and_keep(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u, status='keep')\nend subroutine close_and_keep",
        "summary": "Closes the file unit explicitly with `status='keep'`, which is the default behavior ensuring the file is preserved."
    },
    {
        "id": 527,
        "code": "program check_read_access_mode\n  implicit none\n  character(len=20) :: acc\n  inquire(file='readonly.txt', action=acc)\n  print *, 'Access mode:', trim(acc)\nend program check_read_access_mode",
        "summary": "Inquires the allowed action mode (e.g., READ, WRITE, READWRITE) for 'readonly.txt' and prints it."
    },
    {
        "id": 528,
        "code": "subroutine write_real_value(u, v)\n  implicit none\n  integer, intent(in) :: u\n  real, intent(in) :: v\n  write(u, *) v\nend subroutine write_real_value",
        "summary": "Writes a single real floating-point value to the specified unit using list-directed output."
    },
    {
        "id": 529,
        "code": "program read_int_scalar\n  implicit none\n  integer :: u, val\n  open(newunit=u, file='val.txt')\n  read(u, *) val\n  close(u)\nend program read_int_scalar",
        "summary": "Reads a single integer scalar from 'val.txt', assuming the file contains at least one integer."
    },
    {
        "id": 530,
        "code": "subroutine set_comma_decimal(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, decimal='COMMA')\nend subroutine set_comma_decimal",
        "summary": "Sets the decimal mode of the unit to 'COMMA', used for European-style number formatting (e.g., 3,14)."
    },
    {
        "id": 531,
        "code": "program check_path_exists\n  implicit none\n  logical :: ex\n  inquire(file='subdir/data.txt', exist=ex)\n  if (ex) print *, 'File exists in subdir.'\nend program check_path_exists",
        "summary": "Checks for the existence of a file located in a subdirectory ('subdir/data.txt') and prints a message if found."
    },
    {
        "id": 532,
        "code": "subroutine write_end_string(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, *) 'END'\nend subroutine write_end_string",
        "summary": "Writes the string literal 'END' to the unit, typically used as a sentinel value or footer."
    },
    {
        "id": 533,
        "code": "program read_complex_scalar\n  implicit none\n  integer :: u\n  complex :: c\n  open(newunit=u, file='cplx.txt')\n  read(u, *) c\n  close(u)\nend program read_complex_scalar",
        "summary": "Reads a single complex number scalar from 'cplx.txt' using list-directed input."
    },
    {
        "id": 534,
        "code": "subroutine set_blank_zero_mode(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, blank='ZERO')\nend subroutine set_blank_zero_mode",
        "summary": "Sets the blank interpretation mode to 'ZERO', where spaces in numeric fields are treated as zeros."
    },
    {
        "id": 535,
        "code": "program check_default_encoding\n  implicit none\n  character(len=20) :: enc\n  inquire(unit=10, encoding=enc)\n  if (trim(enc) == 'DEFAULT') print *, 'Using default encoding.'\nend program check_default_encoding",
        "summary": "Checks if the encoding for unit 10 is set to the system 'DEFAULT' (usually ASCII or local codepage)."
    },
    {
        "id": 536,
        "code": "subroutine write_key_val(u, k, v)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: k\n  integer, intent(in) :: v\n  write(u, '(A, \"=\", I0)') trim(k), v\nend subroutine write_key_val",
        "summary": "Writes a key-value pair (String=Integer) to the unit, with the key trimmed of whitespace."
    },
    {
        "id": 537,
        "code": "program read_non_advancing_char\n  implicit none\n  integer :: u\n  character :: c\n  open(newunit=u, file='input.txt')\n  read(u, '(A1)', advance='no') c\n  close(u)\nend program read_non_advancing_char",
        "summary": "Reads the very first character of 'input.txt' using non-advancing I/O without moving to the next line."
    },
    {
        "id": 538,
        "code": "subroutine write_eof(u)\n  implicit none\n  integer, intent(in) :: u\n  endfile(u)\nend subroutine write_eof",
        "summary": "Writes an end-of-file record to the specified unit, terminating the file at the current position."
    },
    {
        "id": 539,
        "code": "program check_formatted_prop\n  implicit none\n  character(len=20) :: fmt\n  inquire(file='data.txt', formatted=fmt)\n  print *, 'Formatted:', trim(fmt)\nend program check_formatted_prop",
        "summary": "Inquires whether 'data.txt' supports formatted I/O and prints the result."
    },
    {
        "id": 540,
        "code": "subroutine write_msg(u, m)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: m\n  write(u, *) trim(m)\nend subroutine write_msg",
        "summary": "Writes a message string to the unit using list-directed output, trimming trailing spaces."
    },
    {
        "id": 541,
        "code": "program read_inquire_opened\n  implicit none\n  logical :: is_open\n  inquire(unit=20, opened=is_open)\n  print *, 'Unit 20 Open:', is_open\nend program read_inquire_opened",
        "summary": "Checks if unit number 20 is currently open and prints the boolean result."
    },
    {
        "id": 542,
        "code": "subroutine write_star_char(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)') '*'\nend subroutine write_star_char",
        "summary": "Writes a single asterisk character on a new line to the specified unit."
    },
    {
        "id": 543,
        "code": "program check_unformatted_prop\n  implicit none\n  character(len=20) :: unf\n  inquire(file='bin.dat', unformatted=unf)\n  print *, 'Unformatted:', trim(unf)\nend program check_unformatted_prop",
        "summary": "Inquires whether 'bin.dat' supports unformatted (binary) I/O and prints the result."
    },
    {
        "id": 544,
        "code": "subroutine open_append_status_old(u, f)\n  implicit none\n  integer, intent(out) :: u\n  character(len=*), intent(in) :: f\n  open(newunit=u, file=f, position='append', status='old')\nend subroutine open_append_status_old",
        "summary": "Opens an existing file (`status='old'`) in append mode, ready to add data to the end."
    },
    {
        "id": 545,
        "code": "program read_skip_line\n  implicit none\n  integer :: u\n  open(newunit=u, file='list.txt')\n  read(u, *) ! Skip\n  close(u)\nend program read_skip_line",
        "summary": "Opens 'list.txt' and reads (skips) the first line without storing the data."
    },
    {
        "id": 546,
        "code": "subroutine close_keep(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u, status='keep')\nend subroutine close_keep",
        "summary": "Closes the unit while explicitly stating to keep the file (default behavior)."
    },
    {
        "id": 547,
        "code": "program check_action_mode\n  implicit none\n  character(len=20) :: act\n  inquire(file='log.txt', action=act)\n  print *, 'Action:', trim(act)\nend program check_action_mode",
        "summary": "Inquires the current action mode (READ, WRITE, READWRITE) of 'log.txt' and prints it."
    },
    {
        "id": 548,
        "code": "subroutine write_float(u, f)\n  implicit none\n  integer, intent(in) :: u\n  real, intent(in) :: f\n  write(u, *) f\nend subroutine write_float",
        "summary": "Writes a single floating-point number to the unit using default formatting."
    },
    {
        "id": 549,
        "code": "program read_int_val\n  implicit none\n  integer :: u, val\n  open(newunit=u, file='num.txt')\n  read(u, *) val\n  close(u)\nend program read_int_val",
        "summary": "Reads a single integer from 'num.txt' using list-directed input."
    },
    {
        "id": 550,
        "code": "subroutine set_decimal_comma_mode(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, decimal='COMMA')\nend subroutine set_decimal_comma_mode",
        "summary": "Sets the decimal interpretation to 'COMMA' for the specified open unit."
    },
    {
        "id": 551,
        "code": "program check_exist_status\n  implicit none\n  logical :: ex\n  inquire(file='check.txt', exist=ex)\n  print *, 'Exists:', ex\nend program check_exist_status",
        "summary": "Checks if 'check.txt' exists and prints the boolean result."
    },
    {
        "id": 552,
        "code": "subroutine write_done(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, *) 'DONE'\nend subroutine write_done",
        "summary": "Writes the string 'DONE' to the unit."
    },
    {
        "id": 553,
        "code": "program read_complex\n  implicit none\n  integer :: u\n  complex :: z\n  open(newunit=u, file='z.txt')\n  read(u, *) z\n  close(u)\nend program read_complex",
        "summary": "Reads a single complex number from 'z.txt'."
    },
    {
        "id": 554,
        "code": "subroutine set_blank_null_mode(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, blank='NULL')\nend subroutine set_blank_null_mode",
        "summary": "Sets the blank interpretation to 'NULL' (ignore blanks) for the unit."
    },
    {
        "id": 555,
        "code": "program check_encoding_utf8\n  implicit none\n  character(len=20) :: enc\n  inquire(file='utf.txt', encoding=enc)\n  print *, 'Encoding:', trim(enc)\nend program check_encoding_utf8",
        "summary": "Inquires the encoding of 'utf.txt' and prints it."
    },
    {
        "id": 556,
        "code": "subroutine write_assignment(u, var, val)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: var\n  integer, intent(in) :: val\n  write(u, '(A, \" = \", I0)') trim(var), val\nend subroutine write_assignment",
        "summary": "Writes an assignment string (e.g., 'x = 5') to the unit."
    },
    {
        "id": 557,
        "code": "program read_first_char_no_adv\n  implicit none\n  integer :: u\n  character :: c\n  open(newunit=u, file='f.txt')\n  read(u, '(A1)', advance='no') c\n  close(u)\nend program read_first_char_no_adv",
        "summary": "Reads the first character of 'f.txt' without advancing the line."
    },
    {
        "id": 558,
        "code": "subroutine write_file_end(u)\n  implicit none\n  integer, intent(in) :: u\n  endfile(u)\nend subroutine write_file_end",
        "summary": "Writes an end-of-file marker to the unit."
    },
    {
        "id": 559,
        "code": "program check_formatted_flag\n  implicit none\n  character(len=20) :: f\n  inquire(file='a.txt', formatted=f)\n  print *, f\nend program check_formatted_flag",
        "summary": "Prints the formatted access property of 'a.txt'."
    },
    {
        "id": 560,
        "code": "subroutine write_info_log(u, m)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: m\n  write(u, '(A, A)') 'INFO: ', trim(m)\nend subroutine write_info_log",
        "summary": "Writes an informational log message prefixed with 'INFO: '."
    },
    {
        "id": 561,
        "code": "program check_opened_unit\n  implicit none\n  logical :: op\n  inquire(unit=50, opened=op)\n  print *, op\nend program check_opened_unit",
        "summary": "Checks if unit 50 is open and prints the boolean result."
    },
    {
        "id": 562,
        "code": "subroutine write_plus_char(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)') '+'\nend subroutine write_plus_char",
        "summary": "Writes a plus sign on a new line."
    },
    {
        "id": 563,
        "code": "program check_unformatted_flag\n  implicit none\n  character(len=20) :: u\n  inquire(file='b.bin', unformatted=u)\n  print *, u\nend program check_unformatted_flag",
        "summary": "Prints the unformatted access property of 'b.bin'."
    },
    {
        "id": 564,
        "code": "subroutine open_append_old(u, f)\n  implicit none\n  integer, intent(out) :: u\n  character(len=*), intent(in) :: f\n  open(newunit=u, file=f, position='append', status='old')\nend subroutine open_append_old",
        "summary": "Opens an existing file in append mode."
    },
    {
        "id": 565,
        "code": "program read_skip_record_simple\n  implicit none\n  integer :: u\n  open(newunit=u, file='s.txt')\n  read(u, *)\n  close(u)\nend program read_skip_record_simple",
        "summary": "Skips one record in 's.txt'."
    },
    {
        "id": 566,
        "code": "subroutine close_status_keep(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u, status='keep')\nend subroutine close_status_keep",
        "summary": "Closes the unit and keeps the file."
    },
    {
        "id": 567,
        "code": "program check_read_write_action\n  implicit none\n  character(len=20) :: a\n  inquire(file='rw.txt', action=a)\n  print *, a\nend program check_read_write_action",
        "summary": "Prints the action mode (read/write) of 'rw.txt'."
    },
    {
        "id": 568,
        "code": "subroutine write_real_simple(u, x)\n  implicit none\n  integer, intent(in) :: u\n  real, intent(in) :: x\n  write(u, *) x\nend subroutine write_real_simple",
        "summary": "Writes a real number using default formatting."
    },
    {
        "id": 569,
        "code": "program read_single_int\n  implicit none\n  integer :: u, i\n  open(newunit=u, file='i.txt')\n  read(u, *) i\n  close(u)\nend program read_single_int",
        "summary": "Reads one integer from 'i.txt'."
    },
    {
        "id": 570,
        "code": "subroutine set_decimal_point(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, decimal='POINT')\nend subroutine set_decimal_point",
        "summary": "Sets decimal interpretation to 'POINT'."
    },
    {
        "id": 571,
        "code": "program check_file_exist\n  implicit none\n  logical :: x\n  inquire(file='x.txt', exist=x)\n  print *, x\nend program check_file_exist",
        "summary": "Prints existence status of 'x.txt'."
    },
    {
        "id": 572,
        "code": "subroutine write_finish(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, *) 'FINISH'\nend subroutine write_finish",
        "summary": "Writes 'FINISH' to the unit."
    },
    {
        "id": 573,
        "code": "program read_complex_num\n  implicit none\n  integer :: u\n  complex :: z\n  open(newunit=u, file='c.txt')\n  read(u, *) z\n  close(u)\nend program read_complex_num",
        "summary": "Reads a complex number from 'c.txt'."
    },
    {
        "id": 574,
        "code": "subroutine set_blank_zero(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, blank='ZERO')\nend subroutine set_blank_zero",
        "summary": "Sets blank interpretation to 'ZERO'."
    },
    {
        "id": 575,
        "code": "program check_encoding_type\n  implicit none\n  character(len=20) :: e\n  inquire(unit=10, encoding=e)\n  print *, e\nend program check_encoding_type",
        "summary": "Prints the encoding of unit 10."
    },
    {
        "id": 576,
        "code": "subroutine write_param(u, p, v)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: p\n  integer, intent(in) :: v\n  write(u, *) p, '=', v\nend subroutine write_param",
        "summary": "Writes a parameter name and integer value."
    },
    {
        "id": 577,
        "code": "program read_char_no_adv\n  implicit none\n  integer :: u\n  character :: k\n  open(newunit=u, file='k.txt')\n  read(u, '(A1)', advance='no') k\n  close(u)\nend program read_char_no_adv",
        "summary": "Reads one character without advancing."
    },
    {
        "id": 578,
        "code": "subroutine write_endfile(u)\n  implicit none\n  integer, intent(in) :: u\n  endfile(u)\nend subroutine write_endfile",
        "summary": "Writes EOF to the unit."
    },
    {
        "id": 579,
        "code": "program check_fmt_access\n  implicit none\n  character(len=20) :: f\n  inquire(file='t.txt', formatted=f)\n  print *, f\nend program check_fmt_access",
        "summary": "Checks formatted access for 't.txt'."
    },
    {
        "id": 580,
        "code": "subroutine write_warning(u, w)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: w\n  write(u, '(A, A)') 'WARN: ', trim(w)\nend subroutine write_warning",
        "summary": "Writes a warning message."
    },
    {
        "id": 581,
        "code": "program check_open_state\n  implicit none\n  logical :: o\n  inquire(unit=99, opened=o)\n  print *, o\nend program check_open_state",
        "summary": "Checks if unit 99 is open."
    },
    {
        "id": 582,
        "code": "subroutine write_equals(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)') '='\nend subroutine write_equals",
        "summary": "Writes an equals sign."
    },
    {
        "id": 583,
        "code": "program check_unf_access\n  implicit none\n  character(len=20) :: u\n  inquire(file='d.bin', unformatted=u)\n  print *, u\nend program check_unf_access",
        "summary": "Checks unformatted access for 'd.bin'."
    },
    {
        "id": 584,
        "code": "subroutine open_append_text(u, f)\n  implicit none\n  integer, intent(out) :: u\n  character(len=*), intent(in) :: f\n  open(newunit=u, file=f, position='append')\nend subroutine open_append_text",
        "summary": "Opens a file in append mode."
    },
    {
        "id": 585,
        "code": "program read_skip\n  implicit none\n  integer :: u\n  open(newunit=u, file='x.dat')\n  read(u, *)\n  close(u)\nend program read_skip",
        "summary": "Skips a record in 'x.dat'."
    },
    {
        "id": 586,
        "code": "subroutine close_file(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u)\nend subroutine close_file",
        "summary": "Closes the file unit."
    },
    {
        "id": 587,
        "code": "program check_action\n  implicit none\n  character(len=20) :: a\n  inquire(file='z.txt', action=a)\n  print *, a\nend program check_action",
        "summary": "Checks action mode for 'z.txt'."
    },
    {
        "id": 588,
        "code": "subroutine write_val_real(u, r)\n  implicit none\n  integer, intent(in) :: u\n  real, intent(in) :: r\n  write(u, *) r\nend subroutine write_val_real",
        "summary": "Writes a real number."
    },
    {
        "id": 589,
        "code": "program read_one_int\n  implicit none\n  integer :: u, n\n  open(newunit=u, file='n.txt')\n  read(u, *) n\n  close(u)\nend program read_one_int",
        "summary": "Reads one integer."
    },
    {
        "id": 590,
        "code": "subroutine set_decimal_comma(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, decimal='COMMA')\nend subroutine set_decimal_comma",
        "summary": "Sets decimal mode to comma."
    },
    {
        "id": 591,
        "code": "program check_file\n  implicit none\n  logical :: e\n  inquire(file='f.dat', exist=e)\n  print *, e\nend program check_file",
        "summary": "Checks if 'f.dat' exists."
    },
    {
        "id": 592,
        "code": "subroutine write_stop(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, *) 'STOP'\nend subroutine write_stop",
        "summary": "Writes 'STOP' to the unit."
    },
    {
        "id": 593,
        "code": "program read_cplx\n  implicit none\n  integer :: u\n  complex :: c\n  open(newunit=u, file='c.dat')\n  read(u, *) c\n  close(u)\nend program read_cplx",
        "summary": "Reads a complex value."
    },
    {
        "id": 594,
        "code": "subroutine set_blank_null(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, blank='NULL')\nend subroutine set_blank_null",
        "summary": "Sets blank mode to NULL."
    },
    {
        "id": 595,
        "code": "program check_enc\n  implicit none\n  character(len=20) :: e\n  inquire(unit=8, encoding=e)\n  print *, e\nend program check_enc",
        "summary": "Checks encoding of unit 8."
    },
    {
        "id": 596,
        "code": "subroutine write_kv(u, k, v)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: k\n  integer, intent(in) :: v\n  write(u, *) k, v\nend subroutine write_kv",
        "summary": "Writes a key and integer value."
    },
    {
        "id": 597,
        "code": "program read_char_na\n  implicit none\n  integer :: u\n  character :: c\n  open(newunit=u, file='c.txt')\n  read(u, '(A1)', advance='no') c\n  close(u)\nend program read_char_na",
        "summary": "Reads a character non-advancing."
    },
    {
        "id": 598,
        "code": "subroutine write_eof_u(u)\n  implicit none\n  integer, intent(in) :: u\n  endfile(u)\nend subroutine write_eof_u",
        "summary": "Writes EOF to the unit."
    },
    {
        "id": 599,
        "code": "program check_fmt\n  implicit none\n  character(len=20) :: f\n  inquire(file='x.txt', formatted=f)\n  print *, f\nend program check_fmt",
        "summary": "Checks formatted property."
    },
    {
        "id": 600,
        "code": "subroutine write_err(u, e)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: e\n  write(u, '(A, A)') 'ERR: ', trim(e)\nend subroutine write_err",
        "summary": "Writes an error message."
    },
    {
        "id": 601,
        "code": "program check_unit_connection_status\n  implicit none\n  logical :: is_connected\n  inquire(unit=25, opened=is_connected)\n  if (is_connected) then\n    print *, 'Unit 25 is currently connected to a file.'\n  else\n    print *, 'Unit 25 is currently free.'\n  end if\nend program check_unit_connection_status",
        "summary": "Queries the status of I/O unit 25 to determine if it is currently connected to a file (opened) and prints a message indicating its availability."
    },
    {
        "id": 602,
        "code": "subroutine write_fatal_error_log(msg)\n  implicit none\n  character(len=*), intent(in) :: msg\n  integer :: u\n  open(newunit=u, file='fatal.log', status='unknown', position='append')\n  write(u, '(A, \": \", A)') 'FATAL ERROR', trim(msg)\n  close(u)\nend subroutine write_fatal_error_log",
        "summary": "Opens a log file named 'fatal.log' in append mode (creating it if it doesn't exist) and records a fatal error message with a specific prefix."
    },
    {
        "id": 603,
        "code": "program read_stream_integers\n  implicit none\n  integer :: u, val, ios\n  open(newunit=u, file='data.bin', access='stream', status='old')\n  do\n    read(u, iostat=ios) val\n    if (ios /= 0) exit\n    print *, 'Stream read:', val\n  end do\n  close(u)\nend program read_stream_integers",
        "summary": "Reads integer values sequentially from a binary stream file 'data.bin' until an error or end-of-file condition is encountered, utilizing stream access for unformatted data."
    },
    {
        "id": 604,
        "code": "subroutine set_decimal_separator_point(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, decimal='POINT')\nend subroutine set_decimal_separator_point",
        "summary": "Configures the specified open I/O unit to use a decimal point ('.') as the separator for floating-point numbers, ensuring compatibility with standard US/UK numeric formats."
    },
    {
        "id": 605,
        "code": "program check_file_read_permission\n  implicit none\n  character(len=20) :: read_perm\n  inquire(file='secure_config.dat', read=read_perm)\n  if (trim(read_perm) == 'YES') then\n    print *, 'File is readable.'\n  else\n    print *, 'Read permission denied.'\n  end if\nend program check_file_read_permission",
        "summary": "Inquires about the read permissions of 'secure_config.dat' to check if the current process is allowed to read from it, handling cases where permission might be restricted."
    },
    {
        "id": 606,
        "code": "subroutine write_centered_text(u, txt, width)\n  implicit none\n  integer, intent(in) :: u, width\n  character(len=*), intent(in) :: txt\n  integer :: pad\n  pad = max(0, (width - len_trim(txt)) / 2)\n  write(u, '(A)') repeat(' ', pad) // trim(txt)\nend subroutine write_centered_text",
        "summary": "Writes a string to the specified file unit, centering it within a given field width by calculating the necessary left padding with spaces."
    },
    {
        "id": 607,
        "code": "program read_namelist_simulation_params\n  implicit none\n  real :: dt, t_max\n  integer :: steps\n  namelist /sim_params/ dt, t_max, steps\n  integer :: u\n  open(newunit=u, file='sim.nml', status='old')\n  read(u, nml=sim_params)\n  close(u)\n  print *, 'Time step:', dt, ' Max time:', t_max\nend program read_namelist_simulation_params",
        "summary": "Reads simulation parameters (`dt`, `t_max`, `steps`) from a namelist file 'sim.nml', allowing for labeled, order-independent configuration input."
    },
    {
        "id": 608,
        "code": "subroutine write_csv_row_3_cols(u, c1, c2, c3)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: c1, c2, c3\n  write(u, '(A, \",\", A, \",\", A)') trim(c1), trim(c2), trim(c3)\nend subroutine write_csv_row_3_cols",
        "summary": "Writes a single row containing three string columns to a CSV file connected to unit `u`, separating each trimmed string value with a comma."
    },
    {
        "id": 609,
        "code": "program check_direct_access_support\n  implicit none\n  character(len=20) :: dir_access\n  inquire(file='random_access.db', direct=dir_access)\n  if (trim(dir_access) == 'YES') then\n    print *, 'Direct access is supported.'\n  end if\nend program check_direct_access_support",
        "summary": "Verifies if the file 'random_access.db' supports direct access mode (random access by record number) using the inquire statement."
    },
    {
        "id": 610,
        "code": "subroutine write_end_of_data_marker(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)') '*** END OF DATA ***'\nend subroutine write_end_of_data_marker",
        "summary": "Writes a distinct marker string '*** END OF DATA ***' to the specified file unit to explicitly signal the conclusion of a data stream."
    },
    {
        "id": 611,
        "code": "program read_allocatable_block\n  implicit none\n  integer :: u, sz\n  real, allocatable :: block(:)\n  open(newunit=u, file='data_block.txt')\n  read(u, *) sz\n  allocate(block(sz))\n  read(u, *) block\n  print *, 'Read block of size', sz\n  close(u)\nend program read_allocatable_block",
        "summary": "Reads an integer size indicator from a file, dynamically allocates a real array of that size, and then populates the array with data from the subsequent records."
    },
    {
        "id": 612,
        "code": "subroutine check_and_rewind(u)\n  implicit none\n  integer, intent(in) :: u\n  logical :: is_open\n  inquire(unit=u, opened=is_open)\n  if (is_open) then\n    rewind(u)\n    print *, 'Unit', u, 'rewound.'\n  end if\nend subroutine check_and_rewind",
        "summary": "Checks if the specified unit is currently open; if it is, the file pointer is reset to the beginning of the file (rewound) and a message is printed."
    },
    {
        "id": 613,
        "code": "program read_complex_array_file\n  implicit none\n  integer :: u\n  complex :: c_arr(10)\n  open(newunit=u, file='complex_signals.txt')\n  read(u, *) c_arr\n  close(u)\n  print *, 'First element:', c_arr(1)\nend program read_complex_array_file",
        "summary": "Reads an array of 10 complex numbers from 'complex_signals.txt' using list-directed input, where each complex number is typically represented as a pair of reals `(real, imag)`."
    },
    {
        "id": 614,
        "code": "subroutine set_blank_zero_interpretation(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, blank='ZERO')\nend subroutine set_blank_zero_interpretation",
        "summary": "Modifies the behavior of the open unit so that blank spaces within numeric input fields are interpreted as zeros rather than being ignored."
    },
    {
        "id": 615,
        "code": "program check_formatted_io_flag\n  implicit none\n  character(len=20) :: fmt_prop\n  inquire(file='report.txt', formatted=fmt_prop)\n  print *, 'Formatted I/O allowed:', trim(fmt_prop)\nend program check_formatted_io_flag",
        "summary": "Inquires whether 'report.txt' can be opened for formatted (text-based) Input/Output operations and prints the result ('YES', 'NO', or 'UNKNOWN')."
    },
    {
        "id": 616,
        "code": "subroutine write_key_value_int(u, key, val)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: key\n  integer, intent(in) :: val\n  write(u, '(A, \" = \", I0)') trim(key), val\nend subroutine write_key_value_int",
        "summary": "Writes a key-value pair to the file in the format 'Key = Value', where the value is an integer and the key is a string trimmed of trailing spaces."
    },
    {
        "id": 617,
        "code": "program read_non_advancing_string\n  implicit none\n  integer :: u\n  character(len=5) :: chunk\n  open(newunit=u, file='data.txt')\n  read(u, '(A5)', advance='no') chunk\n  print *, 'Read chunk:', chunk\n  close(u)\nend program read_non_advancing_string",
        "summary": "Reads exactly 5 characters from the beginning of 'data.txt' into a string variable without advancing the file pointer to the next record (line)."
    },
    {
        "id": 618,
        "code": "subroutine write_file_eof(u)\n  implicit none\n  integer, intent(in) :: u\n  endfile(u)\nend subroutine write_file_eof",
        "summary": "Explicitly writes an End-Of-File (EOF) record to the specified unit at the current position, truncating any data that might exist after this point."
    },
    {
        "id": 619,
        "code": "program check_unformatted_io_flag\n  implicit none\n  character(len=20) :: unf_prop\n  inquire(file='blob.dat', unformatted=unf_prop)\n  print *, 'Unformatted I/O allowed:', trim(unf_prop)\nend program check_unformatted_io_flag",
        "summary": "Inquires whether 'blob.dat' can be opened for unformatted (binary) Input/Output operations, which is essential for handling raw data files."
    },
    {
        "id": 620,
        "code": "subroutine write_warning_msg(u, msg)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: msg\n  write(u, '(A, A)') 'WARNING: ', trim(msg)\nend subroutine write_warning_msg",
        "summary": "Writes a warning message to the specified output unit, automatically prefixing the provided text with the label 'WARNING: '."
    },
    {
        "id": 621,
        "code": "program read_inquire_opened_status\n  implicit none\n  logical :: is_open\n  inquire(unit=42, opened=is_open)\n  if (is_open) print *, 'Unit 42 is active.'\nend program read_inquire_opened_status",
        "summary": "Checks the status of unit number 42 to see if it is currently active (opened) and prints a confirmation message if it is."
    },
    {
        "id": 622,
        "code": "subroutine write_plus_sign(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)') '+'\nend subroutine write_plus_sign",
        "summary": "Writes a single plus sign ('+') character on a new line to the specified file unit, typically used as a visible marker or separator."
    },
    {
        "id": 623,
        "code": "program check_exist_in_directory\n  implicit none\n  logical :: file_exists\n  inquire(file='logs/error.log', exist=file_exists)\n  if (file_exists) print *, 'Error log found.'\nend program check_exist_in_directory",
        "summary": "Checks for the existence of a file located within a subdirectory ('logs/error.log') and prints a message if the file is found on the filesystem."
    },
    {
        "id": 624,
        "code": "subroutine open_append_existing(u, fname)\n  implicit none\n  integer, intent(out) :: u\n  character(len=*), intent(in) :: fname\n  open(newunit=u, file=fname, position='append', status='old')\nend subroutine open_append_existing",
        "summary": "Opens an existing file (`status='old'`) in 'append' mode, allowing new data to be written to the end of the file without overwriting previous content."
    },
    {
        "id": 625,
        "code": "program read_skip_header_line\n  implicit none\n  integer :: u\n  open(newunit=u, file='measurements.csv')\n  read(u, *) ! Ignore header\n  close(u)\nend program read_skip_header_line",
        "summary": "Opens 'measurements.csv' and performs a dummy read operation to skip the first line (header) of the file before closing it."
    },
    {
        "id": 626,
        "code": "subroutine close_and_keep_file(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u, status='keep')\nend subroutine close_and_keep_file",
        "summary": "Closes the specified file unit while explicitly setting the status to 'keep', ensuring the file remains on the disk after the program disconnects."
    },
    {
        "id": 627,
        "code": "program check_read_write_action\n  implicit none\n  character(len=20) :: action_mode\n  inquire(file='database.db', action=action_mode)\n  print *, 'Current action mode:', trim(action_mode)\nend program check_read_write_action",
        "summary": "Inquires about the current action mode (e.g., READ, WRITE, or READWRITE) permitted for the file 'database.db' and prints the result."
    },
    {
        "id": 628,
        "code": "subroutine write_single_real(u, val)\n  implicit none\n  integer, intent(in) :: u\n  real, intent(in) :: val\n  write(u, *) val\nend subroutine write_single_real",
        "summary": "Writes a single real floating-point value to the specified unit using the default list-directed formatting provided by the compiler."
    },
    {
        "id": 629,
        "code": "program read_single_integer_file\n  implicit none\n  integer :: u, count\n  open(newunit=u, file='count.txt')\n  read(u, *) count\n  close(u)\nend program read_single_integer_file",
        "summary": "Opens 'count.txt' and reads a single integer value from the beginning of the file into the variable `count`."
    },
    {
        "id": 630,
        "code": "subroutine set_comma_decimal_mode(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, decimal='COMMA')\nend subroutine set_comma_decimal_mode",
        "summary": "Sets the decimal interpretation mode for the specified unit to 'COMMA', which allows reading and writing numbers using a comma as the decimal separator (e.g., 3,14)."
    },
    {
        "id": 631,
        "code": "program check_file_existence_simple\n  implicit none\n  logical :: exists\n  inquire(file='config.ini', exist=exists)\n  print *, 'Config exists:', exists\nend program check_file_existence_simple",
        "summary": "Performs a simple check to see if the file 'config.ini' exists in the current directory and prints the boolean result."
    },
    {
        "id": 632,
        "code": "subroutine write_stop_command(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)') 'STOP_CMD'\nend subroutine write_stop_command",
        "summary": "Writes the specific command string 'STOP_CMD' to the given file unit, possibly to signal a termination instruction to another process."
    },
    {
        "id": 633,
        "code": "program read_complex_value_data\n  implicit none\n  integer :: u\n  complex :: reading\n  open(newunit=u, file='sensor_c.dat')\n  read(u, *) reading\n  close(u)\nend program read_complex_value_data",
        "summary": "Reads a single complex data point from 'sensor_c.dat', interpreting the input as a complex number (usually a pair of reals)."
    },
    {
        "id": 634,
        "code": "subroutine set_blank_null_interpretation(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, blank='NULL')\nend subroutine set_blank_null_interpretation",
        "summary": "Sets the blank interpretation mode to 'NULL' for the specified unit, meaning that blank spaces in numeric input fields will be ignored."
    },
    {
        "id": 635,
        "code": "program check_default_encoding_status\n  implicit none\n  character(len=20) :: enc_type\n  inquire(unit=6, encoding=enc_type)\n  print *, 'Stdout encoding:', trim(enc_type)\nend program check_default_encoding_status",
        "summary": "Inquires about the character encoding used by standard output (unit 6) and prints the result, such as 'DEFAULT' or 'UTF-8'."
    },
    {
        "id": 636,
        "code": "subroutine write_param_name_val(u, name, val)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: name\n  integer, intent(in) :: val\n  write(u, *) trim(name), ' ', val\nend subroutine write_param_name_val",
        "summary": "Writes a parameter name and its corresponding integer value to the file unit, separated by a space, utilizing list-directed output."
    },
    {
        "id": 637,
        "code": "program read_char_no_advance_simple\n  implicit none\n  integer :: u\n  character :: flag\n  open(newunit=u, file='status_flag.txt')\n  read(u, '(A1)', advance='no') flag\n  close(u)\nend program read_char_no_advance_simple",
        "summary": "Reads a single status character from 'status_flag.txt' using non-advancing I/O, ensuring the file position does not move to the next line."
    },
    {
        "id": 638,
        "code": "subroutine write_endfile_record(u)\n  implicit none\n  integer, intent(in) :: u\n  endfile(u)\nend subroutine write_endfile_record",
        "summary": "Writes an End-Of-File record to the specified unit, ensuring that any subsequent reads will encounter an EOF condition at this point."
    },
    {
        "id": 639,
        "code": "program check_formatted_access_flag\n  implicit none\n  character(len=20) :: fmt_acc\n  inquire(file='source_code.f90', formatted=fmt_acc)\n  print *, 'Formatted access:', fmt_acc\nend program check_formatted_access_flag",
        "summary": "Checks if the source code file 'source_code.f90' can be accessed as a formatted text file and prints the status."
    },
    {
        "id": 640,
        "code": "subroutine write_error_prefix(u, err_text)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: err_text\n  write(u, '(A, A)') 'ERR: ', trim(err_text)\nend subroutine write_error_prefix",
        "summary": "Writes an error message to the specified unit, automatically prefixing the provided text with the label 'ERR: ' for easier log filtering."
    },
    {
        "id": 641,
        "code": "program check_unit_open_boolean\n  implicit none\n  logical :: unit_open\n  inquire(unit=11, opened=unit_open)\n  print *, 'Unit 11 open?', unit_open\nend program check_unit_open_boolean",
        "summary": "Inquires whether unit number 11 is currently open and prints the resulting boolean value (`T` or `F`)."
    },
    {
        "id": 642,
        "code": "subroutine write_equals_separator(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)') '===================='\nend subroutine write_equals_separator",
        "summary": "Writes a separator line consisting of 20 equals signs to the specified file unit to visually divide sections of output."
    },
    {
        "id": 643,
        "code": "program check_unformatted_binary_flag\n  implicit none\n  character(len=20) :: unf_acc\n  inquire(file='raw_data.bin', unformatted=unf_acc)\n  print *, 'Unformatted access:', unf_acc\nend program check_unformatted_binary_flag",
        "summary": "Verifies if 'raw_data.bin' supports unformatted (binary) access and prints the result, indicating if binary I/O is permissible."
    },
    {
        "id": 644,
        "code": "subroutine open_append_old_status(u, filename)\n  implicit none\n  integer, intent(out) :: u\n  character(len=*), intent(in) :: filename\n  open(newunit=u, file=filename, position='append', status='old')\nend subroutine open_append_old_status",
        "summary": "Opens an existing file in 'append' mode using `status='old'`, ensuring that write operations add data to the end of the file."
    },
    {
        "id": 645,
        "code": "program read_skip_single_record\n  implicit none\n  integer :: u\n  open(newunit=u, file='temp_list.txt')\n  read(u, *) ! Discard first record\n  close(u)\nend program read_skip_single_record",
        "summary": "Opens 'temp_list.txt', performs a read operation to skip the first record without storing it, and then closes the file."
    },
    {
        "id": 646,
        "code": "subroutine close_file_keep(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u, status='keep')\nend subroutine close_file_keep",
        "summary": "Closes the specified file unit with `status='keep'`, ensuring that the file is preserved on the filesystem after the connection is terminated."
    },
    {
        "id": 647,
        "code": "program check_read_write_perms\n  implicit none\n  character(len=20) :: rw_mode\n  inquire(file='settings.dat', action=rw_mode)\n  print *, 'Action allowed:', trim(rw_mode)\nend program check_read_write_perms",
        "summary": "Inquires about the permitted I/O actions (READ, WRITE, READWRITE) for 'settings.dat' and prints the current mode."
    },
    {
        "id": 648,
        "code": "subroutine write_float_val(u, f)\n  implicit none\n  integer, intent(in) :: u\n  real, intent(in) :: f\n  write(u, *) f\nend subroutine write_float_val",
        "summary": "Writes a single floating-point number `f` to the specified unit using standard list-directed output formatting."
    },
    {
        "id": 649,
        "code": "program read_one_integer_val\n  implicit none\n  integer :: u, num\n  open(newunit=u, file='number.txt')\n  read(u, *) num\n  close(u)\nend program read_one_integer_val",
        "summary": "Opens 'number.txt' and reads a single integer value from it into the variable `num` using default formatting."
    },
    {
        "id": 650,
        "code": "subroutine set_decimal_point_mode(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, decimal='POINT')\nend subroutine set_decimal_point_mode",
        "summary": "Configures the open unit to use a decimal point ('.') as the numeric separator, ensuring compliance with US/UK number formats."
    },
    {
        "id": 651,
        "code": "program check_file_present\n  implicit none\n  logical :: present\n  inquire(file='input.dat', exist=present)\n  print *, 'File input.dat present:', present\nend program check_file_present",
        "summary": "Checks if the file 'input.dat' exists in the current directory and prints a boolean value indicating its presence."
    },
    {
        "id": 652,
        "code": "subroutine write_completion_msg(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, *) 'COMPLETED'\nend subroutine write_completion_msg",
        "summary": "Writes the status message 'COMPLETED' to the specified file unit to indicate that a task or process has finished."
    },
    {
        "id": 653,
        "code": "program read_complex_item\n  implicit none\n  integer :: u\n  complex :: z_val\n  open(newunit=u, file='impedance.txt')\n  read(u, *) z_val\n  close(u)\nend program read_complex_item",
        "summary": "Reads a complex number from 'impedance.txt', parsing it as a pair of real numbers representing the real and imaginary parts."
    },
    {
        "id": 654,
        "code": "subroutine set_blank_zero_mode_unit(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, blank='ZERO')\nend subroutine set_blank_zero_mode_unit",
        "summary": "Sets the blank interpretation for the unit to 'ZERO', causing any spaces in read numeric fields to be treated as zeros."
    },
    {
        "id": 655,
        "code": "program check_unit_encoding\n  implicit none\n  character(len=20) :: enc\n  inquire(unit=8, encoding=enc)\n  print *, 'Unit 8 Encoding:', trim(enc)\nend program check_unit_encoding",
        "summary": "Inquires about the character encoding (e.g., UTF-8, DEFAULT) configured for unit 8 and prints the result."
    },
    {
        "id": 656,
        "code": "subroutine write_labeled_int(u, label, val)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: label\n  integer, intent(in) :: val\n  write(u, *) trim(label), val\nend subroutine write_labeled_int",
        "summary": "Writes a string label followed by an integer value to the specified unit, separated by a space, using list-directed output."
    },
    {
        "id": 657,
        "code": "program read_first_char_only\n  implicit none\n  integer :: u\n  character :: ch\n  open(newunit=u, file='alphabet.txt')\n  read(u, '(A1)', advance='no') ch\n  close(u)\nend program read_first_char_only",
        "summary": "Reads only the first character from 'alphabet.txt' using non-advancing I/O, leaving the rest of the line unread."
    },
    {
        "id": 658,
        "code": "subroutine write_endfile_cmd(u)\n  implicit none\n  integer, intent(in) :: u\n  endfile(u)\nend subroutine write_endfile_cmd",
        "summary": "Writes an End-Of-File marker to the specified unit, ensuring that the file logical end is set at the current position."
    },
    {
        "id": 659,
        "code": "program check_formatted_status\n  implicit none\n  character(len=20) :: f_stat\n  inquire(file='notes.txt', formatted=f_stat)\n  print *, 'Formatted status:', f_stat\nend program check_formatted_status",
        "summary": "Checks the 'formatted' property of 'notes.txt' via the inquire statement to see if text-based I/O is supported."
    },
    {
        "id": 660,
        "code": "subroutine write_fail_msg(u, msg)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: msg\n  write(u, '(A, A)') 'FAIL: ', trim(msg)\nend subroutine write_fail_msg",
        "summary": "Writes a failure message to the unit, prefixing the provided text with 'FAIL: ' to denote an error condition."
    },
    {
        "id": 661,
        "code": "program check_opened_unit_99\n  implicit none\n  logical :: op\n  inquire(unit=99, opened=op)\n  print *, 'Is unit 99 open?', op\nend program check_opened_unit_99",
        "summary": "Checks if unit number 99 is currently opened and prints the resulting boolean value."
    },
    {
        "id": 662,
        "code": "subroutine write_dash_separator(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)') '-'\nend subroutine write_dash_separator",
        "summary": "Writes a single dash ('-') on a new line to the specified output unit, often used as a simple list bullet or separator."
    },
    {
        "id": 663,
        "code": "program check_unformatted_status\n  implicit none\n  character(len=20) :: unf_stat\n  inquire(file='matrix.bin', unformatted=unf_stat)\n  print *, 'Unformatted status:', unf_stat\nend program check_unformatted_status",
        "summary": "Inquires the 'unformatted' property of 'matrix.bin' to verify if binary data storage is supported for this file."
    },
    {
        "id": 664,
        "code": "subroutine open_file_append(u, fname)\n  implicit none\n  integer, intent(out) :: u\n  character(len=*), intent(in) :: fname\n  open(newunit=u, file=fname, position='append')\nend subroutine open_file_append",
        "summary": "Opens the specified file in 'append' mode, ensuring that any subsequent writes are added to the end of the file."
    },
    {
        "id": 665,
        "code": "program read_skip_first_line\n  implicit none\n  integer :: u\n  open(newunit=u, file='data_list.txt')\n  read(u, *) ! Skip\n  close(u)\nend program read_skip_first_line",
        "summary": "Opens 'data_list.txt', skips the first line by performing a dummy read, and then closes the file."
    },
    {
        "id": 666,
        "code": "subroutine close_and_preserve(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u, status='keep')\nend subroutine close_and_preserve",
        "summary": "Closes the I/O unit `u` with `status='keep'`, explicitly preventing the file from being deleted upon closure."
    },
    {
        "id": 667,
        "code": "program check_action_rw\n  implicit none\n  character(len=20) :: act\n  inquire(file='store.db', action=act)\n  print *, 'Access Action:', act\nend program check_action_rw",
        "summary": "Checks the allowed I/O action (READ, WRITE, or READWRITE) for the file 'store.db' and prints it."
    },
    {
        "id": 668,
        "code": "subroutine write_real_default(u, r)\n  implicit none\n  integer, intent(in) :: u\n  real, intent(in) :: r\n  write(u, *) r\nend subroutine write_real_default",
        "summary": "Writes a real number to the unit using default list-directed formatting."
    },
    {
        "id": 669,
        "code": "program read_single_int_data\n  implicit none\n  integer :: u, val\n  open(newunit=u, file='int_data.txt')\n  read(u, *) val\n  close(u)\nend program read_single_int_data",
        "summary": "Reads a single integer data item from 'int_data.txt' into the variable `val`."
    },
    {
        "id": 670,
        "code": "subroutine set_decimal_mode_comma(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, decimal='COMMA')\nend subroutine set_decimal_mode_comma",
        "summary": "Sets the decimal separator mode to 'COMMA' for the specified unit, facilitating European numeric input/output."
    },
    {
        "id": 671,
        "code": "program check_file_ex\n  implicit none\n  logical :: x\n  inquire(file='verify.txt', exist=x)\n  print *, 'Exists:', x\nend program check_file_ex",
        "summary": "Checks if 'verify.txt' exists on the filesystem and prints the boolean result."
    },
    {
        "id": 672,
        "code": "subroutine write_halt_msg(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, *) 'HALT'\nend subroutine write_halt_msg",
        "summary": "Writes the message 'HALT' to the specified output unit."
    },
    {
        "id": 673,
        "code": "program read_complex_scalar_val\n  implicit none\n  integer :: u\n  complex :: cmp\n  open(newunit=u, file='cmp.txt')\n  read(u, *) cmp\n  close(u)\nend program read_complex_scalar_val",
        "summary": "Reads a single complex number scalar from the file 'cmp.txt'."
    },
    {
        "id": 674,
        "code": "subroutine set_blank_zero_unit(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, blank='ZERO')\nend subroutine set_blank_zero_unit",
        "summary": "Configures the unit to interpret blank spaces in numeric inputs as zeros."
    },
    {
        "id": 675,
        "code": "program check_encoding_unit\n  implicit none\n  character(len=20) :: enc\n  inquire(unit=12, encoding=enc)\n  print *, 'Enc:', enc\nend program check_encoding_unit",
        "summary": "Inquires the encoding scheme of unit 12 and prints the result string."
    },
    {
        "id": 676,
        "code": "subroutine write_str_int_pair(u, s, i)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: s\n  integer, intent(in) :: i\n  write(u, *) s, i\nend subroutine write_str_int_pair",
        "summary": "Writes a string and an integer as a pair to the unit using list-directed output."
    },
    {
        "id": 677,
        "code": "program read_char_wait\n  implicit none\n  integer :: u\n  character :: c\n  open(newunit=u, file='char.txt')\n  read(u, '(A1)', advance='no') c\n  close(u)\nend program read_char_wait",
        "summary": "Reads a single character from 'char.txt' using non-advancing I/O."
    },
    {
        "id": 678,
        "code": "subroutine write_eof_marker(u)\n  implicit none\n  integer, intent(in) :: u\n  endfile(u)\nend subroutine write_eof_marker",
        "summary": "Writes an EOF marker to the unit, truncating the file at that point."
    },
    {
        "id": 679,
        "code": "program check_formatted_access\n  implicit none\n  character(len=20) :: f\n  inquire(file='text.dat', formatted=f)\n  print *, 'Fmt:', f\nend program check_formatted_access",
        "summary": "Checks if 'text.dat' supports formatted access and prints the result."
    },
    {
        "id": 680,
        "code": "subroutine write_err_log(u, e)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: e\n  write(u, '(A, A)') 'ERROR: ', trim(e)\nend subroutine write_err_log",
        "summary": "Writes an error log entry prefixed with 'ERROR: ' to the unit."
    },
    {
        "id": 681,
        "code": "program check_unit_open_state\n  implicit none\n  logical :: o\n  inquire(unit=88, opened=o)\n  print *, o\nend program check_unit_open_state",
        "summary": "Checks if unit 88 is open and prints the status."
    },
    {
        "id": 682,
        "code": "subroutine write_equals_sign(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, '(A)') '='\nend subroutine write_equals_sign",
        "summary": "Writes a single equals sign on a new line to the unit."
    },
    {
        "id": 683,
        "code": "program check_unformatted_mode\n  implicit none\n  character(len=20) :: u\n  inquire(file='block.bin', unformatted=u)\n  print *, u\nend program check_unformatted_mode",
        "summary": "Inquires the unformatted access mode of 'block.bin' and prints it."
    },
    {
        "id": 684,
        "code": "subroutine open_file_append_txt(u, f)\n  implicit none\n  integer, intent(out) :: u\n  character(len=*), intent(in) :: f\n  open(newunit=u, file=f, position='append')\nend subroutine open_file_append_txt",
        "summary": "Opens a text file in append mode."
    },
    {
        "id": 685,
        "code": "program read_skip_rec\n  implicit none\n  integer :: u\n  open(newunit=u, file='rec.txt')\n  read(u, *)\n  close(u)\nend program read_skip_rec",
        "summary": "Skips a record in 'rec.txt'."
    },
    {
        "id": 686,
        "code": "subroutine close_keep_status(u)\n  implicit none\n  integer, intent(in) :: u\n  close(u, status='keep')\nend subroutine close_keep_status",
        "summary": "Closes the unit and keeps the file."
    },
    {
        "id": 687,
        "code": "program check_rw_action\n  implicit none\n  character(len=20) :: a\n  inquire(file='rw.dat', action=a)\n  print *, a\nend program check_rw_action",
        "summary": "Prints the read/write action mode of 'rw.dat'."
    },
    {
        "id": 688,
        "code": "subroutine write_val_float(u, v)\n  implicit none\n  integer, intent(in) :: u\n  real, intent(in) :: v\n  write(u, *) v\nend subroutine write_val_float",
        "summary": "Writes a floating-point value to the unit."
    },
    {
        "id": 689,
        "code": "program read_single_num\n  implicit none\n  integer :: u, n\n  open(newunit=u, file='num.dat')\n  read(u, *) n\n  close(u)\nend program read_single_num",
        "summary": "Reads a single number from 'num.dat'."
    },
    {
        "id": 690,
        "code": "subroutine set_decimal_comma_fmt(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, decimal='COMMA')\nend subroutine set_decimal_comma_fmt",
        "summary": "Sets the decimal format to comma for the unit."
    },
    {
        "id": 691,
        "code": "program check_exist_flag\n  implicit none\n  logical :: e\n  inquire(file='test.txt', exist=e)\n  print *, e\nend program check_exist_flag",
        "summary": "Checks if 'test.txt' exists."
    },
    {
        "id": 692,
        "code": "subroutine write_term_msg(u)\n  implicit none\n  integer, intent(in) :: u\n  write(u, *) 'TERMINATED'\nend subroutine write_term_msg",
        "summary": "Writes 'TERMINATED' to the unit."
    },
    {
        "id": 693,
        "code": "program read_complex_data\n  implicit none\n  integer :: u\n  complex :: c\n  open(newunit=u, file='c_data.txt')\n  read(u, *) c\n  close(u)\nend program read_complex_data",
        "summary": "Reads a complex data item from 'c_data.txt'."
    },
    {
        "id": 694,
        "code": "subroutine set_blank_null_fmt(u)\n  implicit none\n  integer, intent(in) :: u\n  open(unit=u, blank='NULL')\nend subroutine set_blank_null_fmt",
        "summary": "Sets the blank format to NULL."
    },
    {
        "id": 695,
        "code": "program check_unit_enc\n  implicit none\n  character(len=20) :: e\n  inquire(unit=7, encoding=e)\n  print *, e\nend program check_unit_enc",
        "summary": "Checks the encoding of unit 7."
    },
    {
        "id": 696,
        "code": "subroutine write_pair(u, k, v)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: k\n  integer, intent(in) :: v\n  write(u, *) k, v\nend subroutine write_pair",
        "summary": "Writes a key-value pair."
    },
    {
        "id": 697,
        "code": "program read_byte_no_adv\n  implicit none\n  integer :: u\n  character :: b\n  open(newunit=u, file='byte.txt')\n  read(u, '(A1)', advance='no') b\n  close(u)\nend program read_byte_no_adv",
        "summary": "Reads a byte non-advancing."
    },
    {
        "id": 698,
        "code": "subroutine write_end_file(u)\n  implicit none\n  integer, intent(in) :: u\n  endfile(u)\nend subroutine write_end_file",
        "summary": "Writes an end file record."
    },
    {
        "id": 699,
        "code": "program check_formatted\n  implicit none\n  character(len=20) :: f\n  inquire(file='y.txt', formatted=f)\n  print *, f\nend program check_formatted",
        "summary": "Checks formatted property of 'y.txt'."
    },
    {
        "id": 700,
        "code": "subroutine write_exception(u, msg)\n  implicit none\n  integer, intent(in) :: u\n  character(len=*), intent(in) :: msg\n  write(u, '(A, A)') 'EXCEPTION: ', trim(msg)\nend subroutine write_exception",
        "summary": "Writes an exception message to the unit."
    }
]