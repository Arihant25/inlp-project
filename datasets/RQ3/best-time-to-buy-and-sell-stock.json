{
    "problem_name": "Best Time to Buy and Sell Stock",
    "problem_slug": "best-time-to-buy-and-sell-stock",
    "difficulty": "easy",
    "topic_tags": [
        "array",
        "dynamic-programming"
    ],
    "solutions": [
        {
            "language": "cpp",
            "time_complexity": "O(n^2)",
            "space_complexity": "O(1)",
            "code": "class Solution {\n  public:\n      int maxProfit(vector<int>& prices) {\n          int res = 0;\n          for (int i = 0; i < prices.size(); i++) {\n              int buy = prices[i];\n              for (int j = i + 1; j < prices.size(); j++) {\n                  int sell = prices[j];\n                  res = max(res, sell - buy);\n              }\n          }\n          return res;\n      }\n  };\n"
        },
        {
            "language": "python",
            "time_complexity": "O(n^2)",
            "space_complexity": "O(1)",
            "code": "class Solution:\n  def maxProfit(self, prices: List[int]) -> int:\n      res = 0\n      for i in range(len(prices)):\n          buy = prices[i]\n          for j in range(i + 1, len(prices)):\n              sell  = prices[j]\n              res = max(res, sell - buy)\n      return res\n"
        },
        {
            "language": "java",
            "time_complexity": "O(n^2)",
            "space_complexity": "O(1)",
            "code": "public class Solution {\n  public int maxProfit(int[] prices) {\n      int res = 0;\n      for (int i = 0; i < prices.length; i++) {\n          int buy = prices[i];\n          for (int j = i + 1; j < prices.length; j++) {\n              int sell = prices[j];\n              res = Math.max(res, sell - buy);\n          }\n      }\n      return res;\n  }\n}\n"
        },
        {
            "language": "swift",
            "time_complexity": "O(n^2)",
            "space_complexity": "O(1)",
            "code": "class Solution {\n  func maxProfit(_ prices: [Int]) -> Int {\n      var res = 0\n      for i in 0..<prices.count {\n          let buy = prices[i]\n          for j in (i + 1)..<prices.count {\n              let sell = prices[j]\n              res = max(res, sell - buy)\n          }\n      }\n      return res\n  }\n}\n"
        },
        {
            "language": "go",
            "time_complexity": "O(n^2)",
            "space_complexity": "O(1)",
            "code": "func maxProfit(prices []int) int {\n  res := 0\n  for i := 0; i < len(prices); i++ {\n      buy := prices[i]\n      for j := i + 1; j < len(prices); j++ {\n          sell := prices[j]\n          res = max(res, sell - buy)\n      }\n  }\n  return res\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n"
        },
        {
            "language": "cpp",
            "time_complexity": "O(n)",
            "space_complexity": "O(1)",
            "code": "class Solution {\n  public:\n      int maxProfit(vector<int>& prices) {\n          int l = 0, r = 1;\n          int maxP = 0;\n\n          while (r < prices.size()) {\n              if (prices[l] < prices[r]) {\n                  int profit = prices[r] - prices[l];\n                  maxP = max(maxP, profit);\n              } else {\n                  l = r;\n              }\n              r++;\n          }\n          return maxP;\n      }\n  };\n"
        },
        {
            "language": "python",
            "time_complexity": "O(n)",
            "space_complexity": "O(1)",
            "code": "class Solution:\n  def maxProfit(self, prices: List[int]) -> int:\n      l, r = 0, 1\n      maxP = 0\n\n      while r < len(prices):\n          if prices[l] < prices[r]:\n              profit = prices[r] - prices[l]\n              maxP = max(maxP, profit)\n          else:\n              l = r\n          r += 1\n      return maxP\n"
        },
        {
            "language": "java",
            "time_complexity": "O(n)",
            "space_complexity": "O(1)",
            "code": "public class Solution {\n  public int maxProfit(int[] prices) {\n      int l = 0, r = 1;\n      int maxP = 0;\n\n      while (r < prices.length) {\n          if (prices[l] < prices[r]) {\n              int profit = prices[r] - prices[l];\n              maxP = Math.max(maxP, profit);\n          } else {\n              l = r;\n          }\n          r++;\n      }\n      return maxP;\n  }\n}\n"
        },
        {
            "language": "swift",
            "time_complexity": "O(n)",
            "space_complexity": "O(1)",
            "code": "class Solution {\n  func maxProfit(_ prices: [Int]) -> Int {\n      var l = 0, r = 1\n      var maxP = 0\n\n      while r < prices.count {\n          if prices[l] < prices[r] {\n              let profit = prices[r] - prices[l]\n              maxP = max(maxP, profit)\n          } else {\n              l = r\n          }\n          r += 1\n      }\n      return maxP\n  }\n}\n"
        },
        {
            "language": "go",
            "time_complexity": "O(n)",
            "space_complexity": "O(1)",
            "code": "func maxProfit(prices []int) int {\n  l, r := 0, 1\n  maxP := 0\n\n  for r < len(prices) {\n      if prices[l] < prices[r] {\n          profit := prices[r] - prices[l]\n          if profit > maxP {\n              maxP = profit\n          }\n      } else {\n          l = r\n      }\n      r++\n  }\n  return maxP\n}\n"
        },
        {
            "language": "cpp",
            "time_complexity": "O(n)",
            "space_complexity": "O(1)",
            "code": "class Solution {\n  public:\n      int maxProfit(vector<int>& prices) {\n          int maxP = 0;\n          int minBuy = prices[0];\n\n          for (int& sell : prices) {\n              maxP = max(maxP, sell - minBuy);\n              minBuy = min(minBuy, sell);\n          }\n          return maxP;\n      }\n  };\n"
        },
        {
            "language": "python",
            "time_complexity": "O(n)",
            "space_complexity": "O(1)",
            "code": "class Solution:\n  def maxProfit(self, prices: List[int]) -> int:\n      maxP = 0\n      minBuy = prices[0]\n\n      for sell in prices:\n          maxP = max(maxP, sell - minBuy)\n          minBuy = min(minBuy, sell)\n      return maxP\n"
        },
        {
            "language": "java",
            "time_complexity": "O(n)",
            "space_complexity": "O(1)",
            "code": "public class Solution {\n  public int maxProfit(int[] prices) {\n      int maxP = 0;\n      int minBuy = prices[0];\n\n      for (int sell : prices) {\n          maxP = Math.max(maxP, sell - minBuy);\n          minBuy = Math.min(minBuy, sell);\n      }\n      return maxP;\n  }\n}\n"
        },
        {
            "language": "swift",
            "time_complexity": "O(n)",
            "space_complexity": "O(1)",
            "code": "class Solution {\n  func maxProfit(_ prices: [Int]) -> Int {\n      var maxP = 0\n      var minBuy = prices[0]\n\n      for sell in prices {\n          maxP = max(maxP, sell - minBuy)\n          minBuy = min(minBuy, sell)\n      }\n      return maxP\n  }\n}\n"
        },
        {
            "language": "go",
            "time_complexity": "O(n)",
            "space_complexity": "O(1)",
            "code": "func maxProfit(prices []int) int {\n  maxP := 0\n  minBuy := math.MaxInt32\n\n  for _, sell := range prices {\n      if sell - minBuy > maxP {\n          maxP = sell - minBuy\n      }\n      if sell < minBuy {\n          minBuy = sell\n      }\n  }\n  return maxP\n}\n"
        }
    ]
}