problem_name: Group Anagram
problem_slug: group-anagram
difficulty: medium
topic_tags:
  - array
  - hashing
  - string
  - sorting

solutions:

  # ---------------- first ----------------

  - language: cpp
    time_complexity: O(m * n log n)
    space_complexity: O(m * n)
    code: |
      class Solution {
        public:
            vector<vector<string>> groupAnagrams(vector<string>& strs) {
                unordered_map<string, vector<string>> res;
                for (const auto& s : strs) {
                    string sortedS = s;
                    sort(sortedS.begin(), sortedS.end());
                    res[sortedS].push_back(s);
                }
                vector<vector<string>> result;
                for (auto& pair : res) {
                    result.push_back(pair.second);
                }
                return result;
            }
        };

  - language: python
    time_complexity: O(m * n log n)
    space_complexity: O(m * n)
    code: |
      class Solution:
        def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
            res = defaultdict(list)
            for s in strs:
                sortedS = ''.join(sorted(s))
                res[sortedS].append(s)
            return list(res.values())

  - language: java
    time_complexity: O(m * n log n)
    space_complexity: O(m * n)
    code: |
      public class Solution {
        public List<List<String>> groupAnagrams(String[] strs) {
            Map<String, List<String>> res = new HashMap<>();
            for (String s : strs) {
                char[] charArray = s.toCharArray();
                Arrays.sort(charArray);
                String sortedS = new String(charArray);
                res.putIfAbsent(sortedS, new ArrayList<>());
                res.get(sortedS).add(s);
            }
            return new ArrayList<>(res.values());
        }
      }

  - language: swift
    time_complexity: O(m * n log n)
    space_complexity: O(m * n)
    code: |
      class Solution {
        func groupAnagrams(_ strs: [String]) -> [[String]] {
            var res = [String: [String]]()

            for s in strs {
                let sortedS = String(s.sorted())
                res[sortedS, default: []].append(s)
            }

            return Array(res.values)
        }
      }

  - language: go
    time_complexity: O(m * n log n)
    space_complexity: O(m * n)
    code: |
      func groupAnagrams(strs []string) [][]string {
        res := make(map[string][]string)

        for _, s := range strs {
            sortedS := sortString(s)
            res[sortedS] = append(res[sortedS], s)
        }

        var result [][]string
        for _, group := range res {
            result = append(result, group)
        }
        return result
      }

      func sortString(s string) string {
      	characters := []rune(s)
      	sort.Slice(characters, func(i, j int) bool {
      		return characters[i] < characters[j]
      	})
      	return string(characters)
      }

  # ---------------- second ----------------

  - language: cpp
    time_complexity: O(m * m)
    space_complexity: O(m * n)
    code: |
      class Solution {
        public:
            vector<vector<string>> groupAnagrams(vector<string>& strs) {
                unordered_map<string, vector<string>> res;
                for (const auto& s : strs) {
                    vector<int> count(26, 0);
                    for (char c : s) {
                        count[c - 'a']++;
                    }
                    string key = to_string(count[0]);
                    for (int i = 1; i < 26; ++i) {
                        key += ',' + to_string(count[i]);
                    }
                    res[key].push_back(s);
                }
                vector<vector<string>> result;
                for (const auto& pair : res) {
                    result.push_back(pair.second);
                }
                return result;
            }
        };

  - language: python
    time_complexity: O(m * m)
    space_complexity: O(m * n)
    code: |
      class Solution:
        def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
            res = defaultdict(list)
            for s in strs:
                count = [0] * 26
                for c in s:
                    count[ord(c) - ord('a')] += 1
                res[tuple(count)].append(s)
            return list(res.values())

  - language: java
    time_complexity: O(m * m)
    space_complexity: O(m * n)
    code: |
      public class Solution {
        public List<List<String>> groupAnagrams(String[] strs) {
            Map<String, List<String>> res = new HashMap<>();
            for (String s : strs) {
                int[] count = new int[26];
                for (char c : s.toCharArray()) {
                    count[c - 'a']++;
                }
                String key = Arrays.toString(count);
                res.putIfAbsent(key, new ArrayList<>());
                res.get(key).add(s);
            }
            return new ArrayList<>(res.values());
        }
      }

  - language: swift
    time_complexity: O(m * m)
    space_complexity: O(m * n)
    code: |
      class Solution {
        func groupAnagrams(_ strs: [String]) -> [[String]] {
            var res = [Array<Int>: [String]]()

            for s in strs {
                var count = [Int](repeating: 0, count: 26)
                for c in s {
                    count[Int(c.asciiValue!) - 97] += 1
                }
                res[count, default: []].append(s)
            }

            return Array(res.values)
        }
      }

  - language: go
    time_complexity: O(m * m)
    space_complexity: O(m * n)
    code: |
      func groupAnagrams(strs []string) [][]string {
        res := make(map[[26]int][]string)

        for _, s := range strs {
            var count [26]int
            for _, c := range s {
                count[c-'a']++
            }
            res[count] = append(res[count], s)
        }

        var result [][]string
        for _, group := range res {
            result = append(result, group)
        }
        return result
      }

  # ---------------- third ----------------

  - language: cpp
    time_complexity: O(n^2)
    space_complexity: O(1)
    code: |
      cclass Solution {
        public:
            vector<int> twoSum(vector<int>& nums, int target) {
                for (int i = 0; i < nums.size(); i++) {
                    for (int j = i + 1; j < nums.size(); j++) {
                        if (nums[i] + nums[j] == target) {
                            return {i, j};
                        }
                    }
                }
                return {};
            }
        };

  - language: python
    time_complexity: O(n^2)
    space_complexity: O(1)
    code: |
      class Solution:
        def twoSum(self, nums: List[int], target: int) -> List[int]:
            for i in range(len(nums)):
                for j in range(i + 1, len(nums)):
                    if nums[i] + nums[j] == target:
                        return [i, j]
            return []

  - language: java
    time_complexity: O(n^2)
    space_complexity: O(1)
    code: |
      public class Solution {
        public int[] twoSum(int[] nums, int target) {
            for (int i = 0; i < nums.length; i++) {
                for (int j = i + 1; j < nums.length; j++) {
                    if (nums[i] + nums[j] == target) {
                        return new int[]{i, j};
                    }
                }
            }
            return new int[0];
        }
      }

  - language: swift
    time_complexity: O(n^2)
    space_complexity: O(1)
    code: |
      class Solution {
        func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
            for i in 0..<nums.count {
                for j in (i + 1)..<nums.count {
                    if nums[i] + nums[j] == target {
                        return [i, j]
                    }
                }
            }
            return []
        }
      }

  - language: go
    time_complexity: O(n^2)
    space_complexity: O(1)
    code: |
      func twoSum(nums []int, target int) []int {
        for i := 0; i < len(nums); i++ {
            for j := i + 1; j < len(nums); j++ {
                if nums[i] + nums[j] == target {
                    return []int{i, j}
                }
            }
        }
        return []int{}
      }
