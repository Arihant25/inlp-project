problem_name: Valid Palindrome
problem_slug: valid-palindrome
difficulty: easy
topic_tags:
  - two-pointers
  - string

solutions:

  # ---------------- first ----------------

  - language: cpp
    time_complexity: O(n^2)
    space_complexity: O(n)
    code: |
      class Solution {
        public:
            int longestConsecutive(vector<int>& nums) {
                int res = 0;
                unordered_set<int> store(nums.begin(), nums.end());

                for (int num : nums) {
                    int streak = 0, curr = num;
                    while (store.find(curr) != store.end()) {
                        streak++;
                        curr++;
                    }
                    res = max(res, streak);
                }
                return res;
            }
        };

  - language: python
    time_complexity: O(n^2)
    space_complexity: O(n)
    code: |
      class Solution:
        def longestConsecutive(self, nums: List[int]) -> int:
            res = 0
            store = set(nums)

            for num in nums:
                streak, curr = 0, num
                while curr in store:
                    streak += 1
                    curr += 1
                res = max(res, streak)
            return res

  - language: java
    time_complexity: O(n^2)
    space_complexity: O(n)
    code: |
      public class Solution {
        public int longestConsecutive(int[] nums) {
            int res = 0;
            Set<Integer> store = new HashSet<>();
            for (int num : nums) {
                store.add(num);
            }

            for (int num : nums) {
                int streak = 0, curr = num;
                while (store.contains(curr)) {
                    streak++;
                    curr++;
                }
                res = Math.max(res, streak);
            }
            return res;
        }
      }

  - language: swift
    time_complexity: O(n^2)
    space_complexity: O(n)
    code: |
      class Solution {
        func longestConsecutive(_ nums: [Int]) -> Int {
            var res = 0
            let store = Set(nums)

            for num in nums {
                var streak = 0
                var curr = num

                while store.contains(curr) {
                    streak += 1
                    curr += 1
                }

                res = max(res, streak)
            }

            return res
        }
      }

  - language: go
    time_complexity: O(n^2)
    space_complexity: O(n)
    code: |
      func longestConsecutive(nums []int) int {
        res := 0
        store := make(map[int]struct{})
        for _, num := range nums {
            store[num] = struct{}{}
        }

        for _, num := range nums {
            streak, curr := 0, num
            for _, ok := store[curr]; ok; _, ok = store[curr] {
                streak++
                curr++
            }
            if streak > res {
                res = streak
            }
        }
        return res
      }

  # ---------------- second ----------------

  - language: cpp
    time_complexity: O(n log n)
    space_complexity: O(n)
    code: |
      class Solution {
        public:
            int longestConsecutive(vector<int>& nums) {
                if (nums.empty()) return 0;
                sort(nums.begin(), nums.end());

                int res = 0, curr = nums[0], streak = 0, i = 0;

                while (i < nums.size()) {
                    if (curr != nums[i]) {
                        curr = nums[i];
                        streak = 0;
                    }
                    while (i < nums.size() && nums[i] == curr) {
                        i++;
                    }
                    streak++;
                    curr++;
                    res = max(res, streak);
                }
                return res;
            }
        };

  - language: python
    time_complexity: O(n log n)
    space_complexity: O(n)
    code: |
      class Solution:
        def longestConsecutive(self, nums: List[int]) -> int:
            if not nums:
                return 0
            res = 0
            nums.sort()

            curr, streak = nums[0], 0
            i = 0
            while i < len(nums):
                if curr != nums[i]:
                    curr = nums[i]
                    streak = 0
                while i < len(nums) and nums[i] == curr:
                    i += 1
                streak += 1
                curr += 1
                res = max(res, streak)
            return res

  - language: java
    time_complexity: O(n log n)
    space_complexity: O(n)
    code: |
      public class Solution {
        public int longestConsecutive(int[] nums) {
            if (nums.length == 0) {
                return 0;
            }
            Arrays.sort(nums);
            int res = 0, curr = nums[0], streak = 0, i = 0;

            while (i < nums.length) {
                if (curr != nums[i]) {
                    curr = nums[i];
                    streak = 0;
                }
                while (i < nums.length && nums[i] == curr) {
                    i++;
                }
                streak++;
                curr++;
                res = Math.max(res, streak);
            }
            return res;
        }
      }

  - language: swift
    time_complexity: O(n log n)
    space_complexity: O(n)
    code: |
      class Solution {
        func longestConsecutive(_ nums: [Int]) -> Int {
            if nums.isEmpty {
                return 0
            }

            var res = 0
            var nums = nums.sorted()

            var curr = nums[0]
            var streak = 0
            var i = 0

            while i < nums.count {
                if curr != nums[i] {
                    curr = nums[i]
                    streak = 0
                }
                while i < nums.count && nums[i] == curr {
                    i += 1
                }
                streak += 1
                curr += 1
                res = max(res, streak)
            }

            return res
        }
      }

  - language: go
    time_complexity: O(n log n)
    space_complexity: O(n)
    code: |
      func longestConsecutive(nums []int) int {
        if len(nums) == 0 {
            return 0
        }
        sort.Ints(nums)

        res := 0
        curr, streak := nums[0], 0
        i := 0
        for i < len(nums) {
            if curr != nums[i] {
                curr = nums[i]
                streak = 0
            }
            for i < len(nums) && nums[i] == curr {
                i++
            }
            streak++
            curr++
            if streak > res {
                res = streak
            }
        }
        return res
      }

  # ---------------- third ----------------

  - language: cpp
    time_complexity: O(n)
    space_complexity: O(n)
    code: |
      class Solution {
        public:
            int longestConsecutive(vector<int>& nums) {
                unordered_set<int> numSet(nums.begin(), nums.end());
                int longest = 0;

                for (int num : numSet) {
                    if (numSet.find(num - 1) == numSet.end()) {
                        int length = 1;
                        while (numSet.find(num + length) != numSet.end()) {
                            length++;
                        }
                        longest = max(longest, length);
                    }
                }
                return longest;
            }
        };

  - language: python
    time_complexity: O(n)
    space_complexity: O(n)
    code: |
      class Solution:
        def longestConsecutive(self, nums: List[int]) -> int:
            numSet = set(nums)
            longest = 0

            for num in numSet:
                if (num - 1) not in numSet:
                    length = 1
                    while (num + length) in numSet:
                        length += 1
                    longest = max(length, longest)
            return longest

  - language: java
    time_complexity: O(n)
    space_complexity: O(n)
    code: |
      public class Solution {
        public int longestConsecutive(int[] nums) {
            Set<Integer> numSet = new HashSet<>();
            for (int num : nums) {
                numSet.add(num);
            }
            int longest = 0;

            for (int num : numSet) {
                if (!numSet.contains(num - 1)) {
                    int length = 1;
                    while (numSet.contains(num + length)) {
                        length++;
                    }
                    longest = Math.max(longest, length);
                }
            }
            return longest;
        }
      }

  - language: swift
    time_complexity: O(n)
    space_complexity: O(n)
    code: |
      class Solution {
        func longestConsecutive(_ nums: [Int]) -> Int {
            let numSet = Set(nums)
            var longest = 0

            for num in numSet {
                if !numSet.contains(num - 1) {
                    var length = 1
                    while numSet.contains(num + length) {
                        length += 1
                    }
                    longest = max(length, longest)
                }
            }

            return longest
        }
      }

  - language: go
    time_complexity: O(n)
    space_complexity: O(n)
    code: |
      func longestConsecutive(nums []int) int {
        numSet := make(map[int]struct{})
        for _, num := range nums {
            numSet[num] = struct{}{}
        }

        longest := 0
        for num := range numSet {
            if _, found := numSet[num-1]; !found {
                length := 1
                for {
                    if _, exists := numSet[num+length]; exists {
                        length++
                    } else {
                        break
                    }
                }
                if length > longest {
                    longest = length
                }
            }
        }
        return longest
      }
