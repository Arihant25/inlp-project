problem_name: Longest Substring Without Repeating Characters
problem_slug: longest-substring-without-repeating-characters
difficulty: medium
topic_tags:
  - hashing
  - string
  - sliding-window

solutions:

  # ---------------- first ----------------

  - language: cpp
    time_complexity: O(n*m)
    space_complexity: O(m)
    code: |
      class Solution {
        public:
            int lengthOfLongestSubstring(string s) {
                int res = 0;
                for (int i = 0; i < s.size(); i++) {
                    unordered_set<char> charSet;
                    for (int j = i; j < s.size(); j++) {
                        if (charSet.find(s[j]) != charSet.end()) {
                            break;
                        }
                        charSet.insert(s[j]);
                    }
                    res = max(res, (int)charSet.size());
                }
                return res;
            }
        };

  - language: python
    time_complexity: O(n*m)
    space_complexity: O(m)
    code: |
      class Solution:
        def lengthOfLongestSubstring(self, s: str) -> int:
            res = 0
            for i in range(len(s)):
                charSet = set()
                for j in range(i, len(s)):
                    if s[j] in charSet:
                        break
                    charSet.add(s[j])
                res = max(res, len(charSet))
            return res

  - language: java
    time_complexity: O(n*m)
    space_complexity: O(m)
    code: |
      public class Solution {
        public int lengthOfLongestSubstring(String s) {
            int res = 0;
            for (int i = 0; i < s.length(); i++) {
                Set<Character> charSet = new HashSet<>();
                for (int j = i; j < s.length(); j++) {
                    if (charSet.contains(s.charAt(j))) {
                        break;
                    }
                    charSet.add(s.charAt(j));
                }
                res = Math.max(res, charSet.size());
            }
            return res;
        }
      }

  #- language: swift
  #  time_complexity: O(n*m)
  #  space_complexity: O(m)
  #  code: |
      

  - language: go
    time_complexity: O(n*m)
    space_complexity: O(m)
    code: |
      func lengthOfLongestSubstring(s string) int {
        res := 0

        for i := 0; i < len(s); i++ {
            charSet := make(map[byte]bool)
            for j := i; j < len(s); j++ {
                if charSet[s[j]] {
                    break
                }
                charSet[s[j]] = true
            }
            if len(charSet) > res {
                res = len(charSet)
            }
        }
        return res
      }

  # ---------------- second ----------------

  - language: cpp
    time_complexity: O(n)
    space_complexity: O(m)
    code: |
      class Solution {
        public:
            int lengthOfLongestSubstring(string s) {
                unordered_map<char, int> mp;
                int l = 0, res = 0;

                for (int r = 0; r < s.size(); r++) {
                    if (mp.find(s[r]) != mp.end()) {
                        l = max(mp[s[r]] + 1, l);
                    }
                    mp[s[r]] = r;
                    res = max(res, r - l + 1);
                }
                return res;
            }
        };

  - language: python
    time_complexity: O(n)
    space_complexity: O(m)
    code: |
      class Solution:
        def lengthOfLongestSubstring(self, s: str) -> int:
            mp = {}
            l = 0
            res = 0

            for r in range(len(s)):
                if s[r] in mp:
                    l = max(mp[s[r]] + 1, l)
                mp[s[r]] = r
                res = max(res, r - l + 1)
            return res

  - language: java
    time_complexity: O(n)
    space_complexity: O(m)
    code: |
      public class Solution {
        public int lengthOfLongestSubstring(String s) {
            HashMap<Character, Integer> mp = new HashMap<>();
            int l = 0, res = 0;

            for (int r = 0; r < s.length(); r++) {
                if (mp.containsKey(s.charAt(r))) {
                    l = Math.max(mp.get(s.charAt(r)) + 1, l);
                }
                mp.put(s.charAt(r), r);
                res = Math.max(res, r - l + 1);
            }
            return res;
        }
      }      

  - language: swift
    time_complexity: O(n)
    space_complexity: O(m)
    code: |
      class Solution {
        func lengthOfLongestSubstring(_ s: String) -> Int {
            var mp = [Character: Int]()
            var l = 0, res = 0
            let chars = Array(s)

            for r in 0..<chars.count {
                if let index = mp[chars[r]] {
                    l = max(index + 1, l)
                }
                mp[chars[r]] = r
                res = max(res, r - l + 1)
            }
            return res
        }
      }

  - language: go
    time_complexity: O(n)
    space_complexity: O(m)
    code: |
      func lengthOfLongestSubstring(s string) int {
        mp := make(map[byte]int)
        l, res := 0, 0

        for r := 0; r < len(s); r++ {
            if idx, found := mp[s[r]]; found {
                l = max(idx+1, l)
            }
            mp[s[r]] = r
            if r - l + 1 > res {
                res = r - l + 1
            }
        }
        return res
      }

  # ---------------- third ----------------

  - language: cpp
    time_complexity: O(n)
    space_complexity: O(1)
    code: |
      class Solution {
        public:
            int maxProfit(vector<int>& prices) {
                int maxP = 0;
                int minBuy = prices[0];

                for (int& sell : prices) {
                    maxP = max(maxP, sell - minBuy);
                    minBuy = min(minBuy, sell);
                }
                return maxP;
            }
        };

  - language: python
    time_complexity: O(n)
    space_complexity: O(1)
    code: |
      class Solution:
        def maxProfit(self, prices: List[int]) -> int:
            maxP = 0
            minBuy = prices[0]

            for sell in prices:
                maxP = max(maxP, sell - minBuy)
                minBuy = min(minBuy, sell)
            return maxP

  - language: java
    time_complexity: O(n)
    space_complexity: O(1)
    code: |
      public class Solution {
        public int maxProfit(int[] prices) {
            int maxP = 0;
            int minBuy = prices[0];

            for (int sell : prices) {
                maxP = Math.max(maxP, sell - minBuy);
                minBuy = Math.min(minBuy, sell);
            }
            return maxP;
        }
      }

  - language: swift
    time_complexity: O(n)
    space_complexity: O(1)
    code: |
      class Solution {
        func maxProfit(_ prices: [Int]) -> Int {
            var maxP = 0
            var minBuy = prices[0]

            for sell in prices {
                maxP = max(maxP, sell - minBuy)
                minBuy = min(minBuy, sell)
            }
            return maxP
        }
      }

  - language: go
    time_complexity: O(n)
    space_complexity: O(1)
    code: |
      func maxProfit(prices []int) int {
        maxP := 0
        minBuy := math.MaxInt32

        for _, sell := range prices {
            if sell - minBuy > maxP {
                maxP = sell - minBuy
            }
            if sell < minBuy {
                minBuy = sell
            }
        }
        return maxP
      }
