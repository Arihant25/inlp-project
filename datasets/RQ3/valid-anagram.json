{
    "problem_name": "Valid Anagram",
    "problem_slug": "valid-anagram",
    "difficulty": "easy",
    "topic_tags": [
        "string",
        "sorting",
        "hashing"
    ],
    "solutions": [
        {
            "language": "cpp",
            "time_complexity": "O(n log n + m log m)",
            "space_complexity": "O(n + m)",
            "code": "class Solution {\n  public:\n      bool isAnagram(string s, string t) {\n          if (s.length() != t.length()) {\n              return false;\n          }\n\n          sort(s.begin(), s.end());\n          sort(t.begin(), t.end());\n          return s == t;\n      }\n  };\n"
        },
        {
            "language": "python",
            "time_complexity": "O(n log n + m log m)",
            "space_complexity": "O(n + m)",
            "code": "class Solution:\n  def isAnagram(self, s: str, t: str) -> bool:\n      if len(s) != len(t):\n          return False\n\n      return sorted(s) == sorted(t)\n"
        },
        {
            "language": "java",
            "time_complexity": "O(n log n + m log m)",
            "space_complexity": "O(n + m)",
            "code": "public class Solution {\n  public boolean isAnagram(String s, String t) {\n      if (s.length() != t.length()) {\n          return false;\n      }\n\n      char[] sSort = s.toCharArray();\n      char[] tSort = t.toCharArray();\n      Arrays.sort(sSort);\n      Arrays.sort(tSort);\n      return Arrays.equals(sSort, tSort);\n  }\n}\n"
        },
        {
            "language": "swift",
            "time_complexity": "O(n log n + m log m)",
            "space_complexity": "O(n + m)",
            "code": "class Solution {\n  func isAnagram(_ s: String, _ t: String) -> Bool {\n      return s.count == t.count && s.sorted() == t.sorted()\n  }\n}\n"
        },
        {
            "language": "go",
            "time_complexity": "O(n log n + m log m)",
            "space_complexity": "O(n + m)",
            "code": "func isAnagram(s string, t string) bool {\n  if len(s) != len(t) {\n      return false\n  }\n\n  sRunes, tRunes := []rune(s), []rune(t)\n  sort.Slice(sRunes, func(i, j int) bool {\n      return sRunes[i] < sRunes[j]\n  })\n  sort.Slice(tRunes, func(i, j int) bool {\n      return tRunes[i] < tRunes[j]\n  })\n\n  for i := range sRunes {\n      if sRunes[i] != tRunes[i] {\n          return false\n      }\n  }\n  return true\n}\n"
        },
        {
            "language": "cpp",
            "time_complexity": "O(n + m)",
            "space_complexity": "O(1)",
            "code": "class Solution {\n  public:\n      bool isAnagram(string s, string t) {\n          if (s.length() != t.length()) {\n              return false;\n          }\n\n          unordered_map<char, int> countS;\n          unordered_map<char, int> countT;\n          for (int i = 0; i < s.length(); i++) {\n              countS[s[i]]++;\n              countT[t[i]]++;\n          }\n          return countS == countT;\n      }\n  };\n"
        },
        {
            "language": "python",
            "time_complexity": "O(n + m)",
            "space_complexity": "O(1)",
            "code": "class Solution:\n  def isAnagram(self, s: str, t: str) -> bool:\n      if len(s) != len(t):\n          return False\n\n      countS, countT = {}, {}\n\n      for i in range(len(s)):\n          countS[s[i]] = 1 + countS.get(s[i], 0)\n          countT[t[i]] = 1 + countT.get(t[i], 0)\n      return countS == countT\n"
        },
        {
            "language": "java",
            "time_complexity": "O(n + m)",
            "space_complexity": "O(1)",
            "code": "public class Solution {\n  public boolean isAnagram(String s, String t) {\n      if (s.length() != t.length()) {\n          return false;\n      }\n\n      HashMap<Character, Integer> countS = new HashMap<>();\n      HashMap<Character, Integer> countT = new HashMap<>();\n      for (int i = 0; i < s.length(); i++) {\n          countS.put(s.charAt(i), countS.getOrDefault(s.charAt(i), 0) + 1);\n          countT.put(t.charAt(i), countT.getOrDefault(t.charAt(i), 0) + 1);\n      }\n      return countS.equals(countT);\n  }\n}\n"
        },
        {
            "language": "swift",
            "time_complexity": "O(n + m)",
            "space_complexity": "O(1)",
            "code": "class Solution {\n  func isAnagram(_ s: String, _ t: String) -> Bool {\n      if s.count != t.count {\n          return false\n      }\n\n      var countS = [Character: Int]()\n      var countT = [Character: Int]()\n\n      let sArray = Array(s)\n      let tArray = Array(t)\n\n      for i in 0..<s.count {\n          countS[sArray[i], default: 0] += 1\n          countT[tArray[i], default: 0] += 1\n      }\n\n      return countS == countT\n  }\n}\n"
        },
        {
            "language": "go",
            "time_complexity": "O(n + m)",
            "space_complexity": "O(1)",
            "code": "func isAnagram(s string, t string) bool {\n  if len(s) != len(t) {\n      return false\n  }\n\n  countS, countT := make(map[rune]int), make(map[rune]int)\n  for i, ch := range s {\n      countS[ch]++\n      countT[rune(t[i])]++\n  }\n\n  for k, v := range countS {\n      if countT[k] != v {\n          return false\n      }\n  }\n  return true\n}\n"
        }
    ]
}